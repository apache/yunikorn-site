"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4113],{22949:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var a=t(13274),o=t(1780);const i={id:"resource_quota_management",title:"Resource Quota Management"},s=void 0,r={id:"user_guide/resource_quota_management",title:"Resource Quota Management",description:"\x3c!--",source:"@site/versioned_docs/version-1.4.0/user_guide/resource_quota_mgmt.md",sourceDirName:"user_guide",slug:"/user_guide/resource_quota_management",permalink:"/docs/1.4.0/user_guide/resource_quota_management",draft:!1,unlisted:!1,tags:[],version:"1.4.0",frontMatter:{id:"resource_quota_management",title:"Resource Quota Management"},sidebar:"docs",previous:{title:"ACLs",permalink:"/docs/1.4.0/user_guide/acls"},next:{title:"Gang Scheduling",permalink:"/docs/1.4.0/user_guide/gang_scheduling"}},u={},c=[{value:"Quota configuration and rules",id:"quota-configuration-and-rules",level:2},{value:"Converting Kubernetes resources and quotas",id:"converting-kubernetes-resources-and-quotas",level:2},{value:"Kubernetes and YuniKorn quota interaction",id:"kubernetes-and-yunikorn-quota-interaction",level:2},{value:"Static queue definition",id:"static-queue-definition",level:2},{value:"Goal",id:"goal",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Run a workload",id:"run-a-workload",level:3},{value:"Namespace to queue mapping",id:"namespace-to-queue-mapping",level:2},{value:"Goal",id:"goal-1",level:3},{value:"Configuration",id:"configuration-1",level:3},{value:"Namespace quota",id:"namespace-quota",level:3},{value:"Run a workload",id:"run-a-workload-1",level:3},{value:"Parent queue mapping for namespaces",id:"parent-queue-mapping-for-namespaces",level:2},{value:"Goal",id:"goal-2",level:3},{value:"Configuration",id:"configuration-2",level:3},{value:"Namespace parent queue",id:"namespace-parent-queue",level:3},{value:"Run a workload",id:"run-a-workload-2",level:3},{value:"Application resource usage report",id:"application-resource-usage-report",level:3}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"quota-configuration-and-rules",children:"Quota configuration and rules"}),"\n",(0,a.jsx)(n.p,{children:"YuniKorn can offer a finer grained resource quota management setup compared to the simple namespace resource quota provided by Kubernetes."}),"\n",(0,a.jsx)(n.p,{children:"On Kubernetes a pod must fit into the namespace quota when the pod is submitted.\nIf the pod does not fit in the namespace quota the pod is rejected.\nThe client must implement a retry-mechanism and re-submit the pod if it needs the pod to be scheduled."}),"\n",(0,a.jsx)(n.p,{children:"Contrary to quotas in Kubernetes YuniKorn does not enforce quotas on submission but only on actively consumed resources.\nTo explain the difference: when using YuniKorn for quota enforcement a new pod submitted to Kubernetes is always accepted.\nYunikorn will queue the pod without counting the queued pod's resources towards the consumed quota.\nWhen YuniKorn tries to schedule the pod it checks at scheduling time if the pod fits in the quota configured for the queue the pod is assigned to.\nIf at that point the pod does not fit in the quota the pod is skipped and not counted in the resource consumption.\nThis means that until a scheduling attempt of a pod is successful a pod it is not consuming resources in the YuniKorn quota system."}),"\n",(0,a.jsxs)(n.p,{children:["Resource quotas in YuniKorn are linked to the queue and its place in the queue hierarchy.\nThe base of the queue structure, the ",(0,a.jsx)(n.code,{children:"root"})," queue, does not allow setting a quota as it reflects the current size of the cluster.\nNode additions and removals update the ",(0,a.jsx)(n.code,{children:"root"})," queue quota automatically."]}),"\n",(0,a.jsxs)(n.p,{children:["Beside the ",(0,a.jsx)(n.code,{children:"root"})," queue the quotas can be set, and is enforced, at any point in the hierarchy.\nEvery queue can have a quota set. The quota is enforced recursively throughout the hierarchy.\nThis means that a child queue can never use more resources than the ",(0,a.jsx)(n.strong,{children:"configured"})," quota of the parent queue.\nSetting a quota on a child queue larger than its parent queue's quota would thus not have any effect and is handled as a configuration error."]}),"\n",(0,a.jsxs)(n.p,{children:["In the hierarchy there are some further rules that need to be considered.\nIf a parent queue has multiple children the sum of the ",(0,a.jsx)(n.strong,{children:"usage"})," of all children combined can never exceed the quota ",(0,a.jsx)(n.strong,{children:"configured"})," on the parent.\nHowever, from a configuration perspective this does not mean that the sum of the ",(0,a.jsx)(n.strong,{children:"configured"})," quotas for all children must be smaller than the parent quota."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Queue Quota",src:t(69126).A+"",width:"1364",height:"732"})}),"\n",(0,a.jsxs)(n.p,{children:["As an example the ",(0,a.jsx)(n.code,{children:"root.parent"})," queue has a quota of 900.\nIt contains three child queues, two with a quota set.\nThe ",(0,a.jsx)(n.code,{children:"root.parent.child1"})," has no quota set and will thus be limited to the ",(0,a.jsx)(n.code,{children:"root.parent"})," quota.\nThe two other queues ",(0,a.jsx)(n.code,{children:"root.parent.child2"})," and ",(0,a.jsx)(n.code,{children:"root.parent.child3"})," each have a quota of 750 set.\nDuring normal operation the total usage of the 3 child queues together will be 900.\nThe applications running in each child queue have a demand of more than 1000 each."]}),"\n",(0,a.jsx)(n.p,{children:"Distribution in that case could be any of:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["all 900 used by just the ",(0,a.jsx)(n.code,{children:"child1"})," queue"]}),"\n",(0,a.jsx)(n.li,{children:"spread out evenly over the 3 queues (300 by each)"}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"child2"})," maxed out using 750, and the left over 150 used by ",(0,a.jsx)(n.code,{children:"child3"})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The exact distribution between the queues will fluctuate and is dependent on the scheduling policies."}),"\n",(0,a.jsx)(n.h2,{id:"converting-kubernetes-resources-and-quotas",children:"Converting Kubernetes resources and quotas"}),"\n",(0,a.jsxs)(n.p,{children:["Resource support for pods is limited to the resources specified as part of the ",(0,a.jsx)(n.em,{children:"requests"})," specification:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"cpu"})," is mapped to ",(0,a.jsx)(n.em,{children:"vcore"})," with the value in milli cpu."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"memory"})," is mapped to ",(0,a.jsx)(n.em,{children:"memory"})," with the value in MB (1 MB = 10^6 B = 1 000 000 B)."]}),"\n",(0,a.jsx)(n.li,{children:"all other resources are mapped as provided."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Extended resource as per the ",(0,a.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",children:"Kubernetes documentation"})," are supported."]}),"\n",(0,a.jsx)(n.p,{children:"Example pod with a single container:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: container-1\n    resources:\n      requests:\n        cpu: "250m"\n        memory: "1Gi"\n        hugepages-1Gi: "1"\n'})}),"\n",(0,a.jsx)(n.p,{children:"The above specification will set pod resources request for scheduling in YuniKorn to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"vcore"})," -> 250m"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"memory"})," -> 1073741824"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"hugepages-1Gi"})," -> 1"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Two remarks:",(0,a.jsx)(n.br,{}),"\n","Multiple container specifications will be aggregated into one total pod resource request automatically. All memory is reported in bytes."]}),"\n",(0,a.jsxs)(n.p,{children:["In the case that static queue definitions are used for a queue there is no limit on the type of resource that can be specified in a quota.\nQuota annotations on namespaces, used as part of the automatic queue creation, are limited to the equivalent ",(0,a.jsx)(n.em,{children:"cpu"})," and ",(0,a.jsx)(n.em,{children:"memory"})," resources.\nSee the ",(0,a.jsx)(n.a,{href:"#Namespace-quota",children:"setup"})," below for the annotations on the namespace for quotas."]}),"\n",(0,a.jsx)(n.h2,{id:"kubernetes-and-yunikorn-quota-interaction",children:"Kubernetes and YuniKorn quota interaction"}),"\n",(0,a.jsx)(n.p,{children:"The recommendation is to turn off, not configure, the Kubernetes Namespace quotas.\nUsing only YuniKorn queue quotas provides a more flexible setup and allows queueing of workloads."}),"\n",(0,a.jsx)(n.p,{children:"In a setup that has both YuniKorn and Kubernetes quotas turned on consider the following points:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Two separate configurations need to be maintained.\nThis increases the maintenance burden, and the possibility of configuration mistakes."}),"\n",(0,a.jsx)(n.li,{children:"Both quotas will be enforced."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Having both quotas turned on can lead to unexpected behaviour.\nThe main issue is the fact that the Kubernetes namespace quota is enforced on submit.\nThere are three combinations of quota configuration that are possible.\nThe 3 combinations could have two effects when used in combination with the YuniKorn quota."}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Both quotas are ",(0,a.jsx)(n.em,{children:"equal"}),": workloads will not be queued, the full configured quota can be used.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Maximum usage and queueing will be limited to the set quota"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Kubernetes quota is ",(0,a.jsx)(n.em,{children:"lower"})," than YuniKorn: the YuniKorn quota will never be reached and workloads will not be queued.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Maximum usage will be limited to the Kubernetes quota."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Kubernetes quota is ",(0,a.jsx)(n.em,{children:"higher"})," than YuniKorn: YuniKorn will limit the usage to the quota set in YuniKorn.\nThe Kubernetes quota will be enforced on submit and thus set the limit for the workload that can be queued on top of the YuniKorn quota.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Maximum usage will be limited to the YuniKorn quota."}),"\n",(0,a.jsx)(n.li,{children:"Workload queueing will be limited to the Kubernetes quota."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"The following configuration examples are just to demonstrate the format needed\nto create a queue hierarchy with quotas set."})}),"\n",(0,a.jsx)(n.h2,{id:"static-queue-definition",children:"Static queue definition"}),"\n",(0,a.jsx)(n.h3,{id:"goal",children:"Goal"}),"\n",(0,a.jsx)(n.p,{children:"A preconfigured hierarchy of queues with a maximum and guaranteed capacity.\nThe users can only submit applications to the leaf queues.\nThis approach manages the resource capacity for each of the queues, which is suitable to the scenarios that queues do not change too often."}),"\n",(0,a.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,a.jsx)(n.p,{children:"Apply the following configuration to YuniKorn's configmap to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["setup 3 queues under ",(0,a.jsx)(n.code,{children:"root"})]}),"\n",(0,a.jsx)(n.li,{children:"each queue has a specific guaranteed and maximum capacity"}),"\n",(0,a.jsx)(n.li,{children:"anyone can submit to any queue"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"partitions:\n  - name: default\n    queues:\n      - name: root\n        submitacl: '*'\n        queues:\n          - name: advertisement\n            resources:\n              guaranteed:\n                memory: 500G\n                vcore: 50\n              max:\n                memory: 800G\n                vcore: 80\n          - name: search\n            resources:\n              guaranteed:\n                memory: 400G\n                vcore: 40\n              max:\n                memory: 600G\n                vcore: 60\n          - name: sandbox\n            resources:\n              guaranteed:\n                memory: 100G\n                vcore: 10\n              max:\n                memory: 100G\n                vcore: 10\n"})}),"\n",(0,a.jsx)(n.h3,{id:"run-a-workload",children:"Run a workload"}),"\n",(0,a.jsxs)(n.p,{children:["In order to run applications in specific queues, you will need to set the following labels in all pod specs.\nAll pods with the same ",(0,a.jsx)(n.code,{children:"applicationID"})," label are considered ti be one application.\nIn the below example the application ",(0,a.jsx)(n.code,{children:"my-test-app"})," will run in the queue ",(0,a.jsx)(n.code,{children:"root.sandbox"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'labels:\n  app: my-test-app\n  applicationId: "my-test-app-01"\n  queue: root.sandbox\n'})}),"\n",(0,a.jsx)(n.h2,{id:"namespace-to-queue-mapping",children:"Namespace to queue mapping"}),"\n",(0,a.jsx)(n.h3,{id:"goal-1",children:"Goal"}),"\n",(0,a.jsxs)(n.p,{children:["Automatically map a Kubernetes ",(0,a.jsx)(n.code,{children:"namespace"})," to a queue in YuniKorn.\nThe user creates the required namespaces in Kubernetes.\nThe YuniKorn k8s shim and core scheduler automatically pass the required information and map the namespace to a queue, creating the queue if it does not exist.\nThe resource quota will be managed by YuniKorn instead of using the Kubernetes namespace quota.\nThis does require the namespaces to be setup without Kubernetes quota enforcement and tags as per the ",(0,a.jsx)(n.a,{href:"#Namespace-quota",children:"setup"})," below."]}),"\n",(0,a.jsx)(n.h3,{id:"configuration-1",children:"Configuration"}),"\n",(0,a.jsx)(n.p,{children:"Apply the following configuration to YuniKorn's configmap:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"partitions:\n  - name: default\n    placementrules:\n      - name: tag\n        value: namespace\n        create: true\n    queues:\n      - name: root\n        submitacl: '*'\n        properties:\n          application.sort.policy: stateaware\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This configuration places an application based on the ",(0,a.jsx)(n.code,{children:"tag"})," rule.\nThe tag selected is the ",(0,a.jsx)(n.code,{children:"namespace"})," tag which is automatically added by the k8s shim to all applications that get created.\nThe ",(0,a.jsx)(n.code,{children:"create"})," flag is set to true which will trigger the creation of the queue with the same name as the namespace if it does not exist."]}),"\n",(0,a.jsxs)(n.p,{children:["Applications within the automatically created child queues will be sorted based sorting policy set on the parent queue.\nIn this case the property ",(0,a.jsx)(n.code,{children:"application.sort.policy"})," is in this configuration set to ",(0,a.jsx)(n.code,{children:"stateaware"}),".\nThis is a simple app sorting policy applicable for batch jobs, you can find more document ",(0,a.jsx)(n.a,{href:"/docs/1.4.0/user_guide/sorting_policies#StateAwarePolicy",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["You can change the configuration using the helm charts during the installation by overwriting the configuration in the\n",(0,a.jsx)(n.a,{href:"https://github.com/apache/yunikorn-release/blob/master/helm-charts/yunikorn/values.yaml#L71-L81",children:"helm chart template"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"namespace-quota",children:"Namespace quota"}),"\n",(0,a.jsx)(n.p,{children:"Namespaces in Kubernetes contain the quota information.\nIf a quota is set on a namespace Kubernetes will automatically enforce the quota.\nIn the case that YuniKorn is used for quota enforcement no quota must be set on the namespace."}),"\n",(0,a.jsx)(n.p,{children:"To allow specifying a quota on the namespace the following annotations should be set in the namespace object:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'yunikorn.apache.org/namespace.quota: "{\\"cpu\\": \\"64\\", \\"memory\\": \\"100G\\", \\"nvidia.com/gpu\\": \\"1\\"}"\n'})}),"\n",(0,a.jsx)(n.p,{children:"YuniKorn will parse these annotations and set the maximum capacity of the queue mapped to this namespace.\nThe values specified follow the standard Kubernetes formatting and unit specification.\nAnnotation value must be a single json compliant string. Ensure double quotes iare escaped properly to not cause any problems."}),"\n",(0,a.jsxs)(n.p,{children:["The example above will limit the queue mapped to the annotated namespace to 64 CPUs, 100GB memory and 1 ",(0,a.jsx)(n.code,{children:"nvidia.com/gpu"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"[DEPRECATED]\nThe below annotations are deprecated and will be removed from next major release.\nThey only support mapping memory and cpu, not other resource types."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'yunikorn.apache.org/namespace.max.cpu: "64"\nyunikorn.apache.org/namespace.max.memory: "100Gi"\n'})}),"\n",(0,a.jsx)(n.p,{children:"The example for the deprecated annotation will set the queue quota to 64 CPUs and 100GB memory."}),"\n",(0,a.jsx)(n.h3,{id:"run-a-workload-1",children:"Run a workload"}),"\n",(0,a.jsx)(n.p,{children:"Applications, and the pods that are part of the application, can be submitted without specific labels.\nYuniKorn will automatically add the required tags.\nThe configured placement rule will create the queue, if required, and add the application to the queue."}),"\n",(0,a.jsxs)(n.p,{children:["For example, if an application is submitted to namespace ",(0,a.jsx)(n.code,{children:"development"}),", then the application will run in the ",(0,a.jsx)(n.code,{children:"root.development"})," queue."]}),"\n",(0,a.jsx)(n.h2,{id:"parent-queue-mapping-for-namespaces",children:"Parent queue mapping for namespaces"}),"\n",(0,a.jsx)(n.h3,{id:"goal-2",children:"Goal"}),"\n",(0,a.jsxs)(n.p,{children:["Though the tag placement rule using the ",(0,a.jsx)(n.code,{children:"namespace"})," tag is capable of placing an application in a queue this might not be enough in all setups.\nIn some cases, multi tenancy for example, namespaces need to be grouped together.\nAdministrators could annotate namespaces which allows dynamic placement of applications based on multiple annotations if placement rules were setup.\nYuniKorn cannot and does not just add all annotations from a namespace to an application."]}),"\n",(0,a.jsx)(n.p,{children:"To help support this grouping case a parent queue can be tagged on a namespace."}),"\n",(0,a.jsx)(n.h3,{id:"configuration-2",children:"Configuration"}),"\n",(0,a.jsx)(n.p,{children:"The configuration for this functionality consists of two pieces:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"the mapping rule"}),"\n",(0,a.jsx)(n.li,{children:"the namespace annotation"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"First we set the following configuration to YuniKorn's configmap:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"partitions:\n   - name: default\n     placementrules:\n        - name: tag\n          value: namespace\n          create: true\n          parent:\n             name: tag\n             value: namespace.parentqueue\n     queues:\n        - name: root\n          queues:\n             - name: production\n               parent: true\n             - name: development\n               parent: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The configuration used for the namespace to queue mapping is the same as ",(0,a.jsx)(n.a,{href:"#Namespace-to-queue-mapping",children:"above"}),".\nAs an extension to the placement rule a ",(0,a.jsx)(n.code,{children:"parent"})," rule is added to support the grouping.\nThe parent rule is used to generate the parent, or the queue above, in the hierarchy.\nThe rule uses the tag ",(0,a.jsx)(n.code,{children:"namespace.parentqueue"})," from the application to generate the parent queue name.\nThe ",(0,a.jsx)(n.code,{children:"namespace.parentqueue"})," tag is automatically added by the Kubernetes shim but does require a namespace annotation (see below)."]}),"\n",(0,a.jsxs)(n.p,{children:["In the example rule configuration given the ",(0,a.jsx)(n.code,{children:"create"})," flag is not set on the parent rule.\nThis means that the parent queue must exist in the configuration otherwise the application submit will fail.\nFor the example configuration this means supported values for the parent are thus limited to ",(0,a.jsx)(n.code,{children:"production"})," and ",(0,a.jsx)(n.code,{children:"development"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Quotas cannot be set on the parent queue using any of these mappings.\nThe quota linked to the namespace is set on the namespace queue not the parent  as per the namespace mapping provided earlier."}),"\n",(0,a.jsxs)(n.p,{children:["Parent queue quotas must always be set directly in the configuration.\nThis requires the ",(0,a.jsx)(n.code,{children:"create"})," flag to be set to ",(0,a.jsx)(n.code,{children:"false"})," on the parent rule."]}),"\n",(0,a.jsx)(n.h3,{id:"namespace-parent-queue",children:"Namespace parent queue"}),"\n",(0,a.jsx)(n.p,{children:"Contrary to the namespace name itself, and inline with the quota settings, the namespaces need to be annotated to use the parent queue mapping.\nNamespace names must be unique in Kubernetes which is not affected by this annotation.\nThe same annotation value may be used for multiple namespaces:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"yunikorn.apache.org/parentqueue: root.production\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The example annotation above will map the parent queue to the existing ",(0,a.jsx)(n.code,{children:"root.production"})," queue.\nNote that the rule will fully qualify the name if needed, you can thus omit the ",(0,a.jsx)(n.code,{children:"root."})," part in the annotation.\nIf the annotation starts with ",(0,a.jsx)(n.code,{children:"root."})," the system assumes it is a fully qualified queue name."]}),"\n",(0,a.jsxs)(n.p,{children:["To complete the picture here is an image that shows the mapping from Kubernetes namespaces to queues in YuniKorn.\nIt uses the annotations on the namespaces in Kubernetes as described, and the example configuration for the mapping rules.\nThe ",(0,a.jsx)(n.code,{children:"finance"})," and ",(0,a.jsx)(n.code,{children:"sales"})," namespaces become queues grouped under the parent queue ",(0,a.jsx)(n.code,{children:"production"}),".\nThe namespaces ",(0,a.jsx)(n.code,{children:"dev"})," and ",(0,a.jsx)(n.code,{children:"test"})," are placed under the ",(0,a.jsx)(n.code,{children:"development"})," parent queue."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Queue Quota",src:t(89462).A+"",width:"1600",height:"624"})}),"\n",(0,a.jsx)(n.h3,{id:"run-a-workload-2",children:"Run a workload"}),"\n",(0,a.jsx)(n.p,{children:"Applications, and the pods that are part of the application, can be submitted without specific labels or changes.\nYuniKorn will add the tags, the placement rules will do the rest.\nThe configured placement rule will create the queues, if required, and add the application to the queue."}),"\n",(0,a.jsxs)(n.p,{children:["Since the namespace ",(0,a.jsx)(n.code,{children:"finance"})," is annotated with the example value, and the rules are in place.\nApplications in the ",(0,a.jsx)(n.code,{children:"finance"})," namespace will run in the ",(0,a.jsx)(n.code,{children:"root.production.finance"})," queue that is created dynamically."]}),"\n",(0,a.jsx)(n.h3,{id:"application-resource-usage-report",children:"Application resource usage report"}),"\n",(0,a.jsxs)(n.p,{children:["The sum of the resources consumed by all the pods of an application is the total resource usage of the application.\nThe resource usage of a pod is measured as ",(0,a.jsx)(n.code,{children:"resource-unit times the runtime length of the pod"}),". For example, if the resource of a pod\nis described as ",(0,a.jsx)(n.code,{children:'cpu: "100m" memory: "500M"'}),", then with a runtime of 30 seconds, the resource consumption will be\n",(0,a.jsx)(n.code,{children:"vcore: 3000, memory: 15000000000"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:['YuniKorn logs an application summary line with prefix "',(0,a.jsx)(n.code,{children:"YK_APP_SUMMARY:"}),"\" upon the application's completion. The summary includes various information about the application including the total resource usage. As an example:"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:'YK_APP_SUMMARY: {"appId":"test-app-id","submissionTime":1685487033533,"startTime":1685487035535,"finishTime":1685488714483,"user":"nobody","queue":"root.test-queue","state":"Completed","rmID":"cluster-A","resourceUsage":{"instType1":{"memory":38315403247616,"vcore":1622000},"instType2":{"memory":368171374608384,"vcore":16245000}}}'})}),"\n",(0,a.jsx)(n.p,{children:"For each instance type used by the application, a resource usage entry is reported in the summary. The resource usage is reported for both cpu and memory, as microcpu-seconds and byte-seconds respectively."}),"\n",(0,a.jsx)(n.p,{children:"As an example, this information could be ingested into a database table. Analysis then could be done to understand historically the needed resources for an application in general, and the requirements needed at a queue level for all applications scheduled to run in the queue. In addition, the resource usage could be translated to resource cost, and charged back to the application owner."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},89462:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/namespace-mapping-703b2384a21c2e401291fbb49acdb1f4.png"},69126:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/queue-resource-quotas-02ec11ddedad1f2057bbc4d3ef1c900a.png"},1780:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(79474);const o={},i=a.createContext(o);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);