"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[56809],{52310:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var s=t(13274),i=t(1780);const r={id:"historical_usage_tracking",title:"Historical Usage Tracking"},d=void 0,l={id:"design/historical_usage_tracking",title:"Historical Usage Tracking",description:"\x3c!--",source:"@site/versioned_docs/version-1.4.0/design/historical_usage_tracking.md",sourceDirName:"design",slug:"/design/historical_usage_tracking",permalink:"/docs/1.4.0/design/historical_usage_tracking",draft:!1,unlisted:!1,tags:[],version:"1.4.0",frontMatter:{id:"historical_usage_tracking",title:"Historical Usage Tracking"},sidebar:"docs",previous:{title:"User Based Quota Enforcement",permalink:"/docs/1.4.0/design/user_group_resource_usage_enforcement"},next:{title:"Simplifying Interface Messages",permalink:"/docs/1.4.0/design/interface_message_simplification"}},a={},o=[{value:"Introduction",id:"introduction",level:2},{value:"Goals",id:"goals",level:2},{value:"Non Goals",id:"non-goals",level:2},{value:"Existing Event System",id:"existing-event-system",level:2},{value:"Scheduler integration",id:"scheduler-integration",level:3},{value:"Event storage",id:"event-storage",level:3},{value:"Publishing events",id:"publishing-events",level:3},{value:"Event System Updates",id:"event-system-updates",level:2},{value:"Event description",id:"event-description",level:3},{value:"Event types",id:"event-types",level:3},{value:"Change types",id:"change-types",level:3},{value:"Change details",id:"change-details",level:3},{value:"Content definition",id:"content-definition",level:3},{value:"Event storage",id:"event-storage-1",level:2},{value:"Publishing events",id:"publishing-events-1",level:3},{value:"SHIM events",id:"shim-events",level:4},{value:"REST",id:"rest",level:4},{value:"Streaming",id:"streaming",level:4},{value:"Event overview",id:"event-overview",level:2},{value:"Generic events",id:"generic-events",level:3},{value:"Shim events",id:"shim-events-1",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Performance considerations",id:"performance-considerations",level:2},{value:"Memory usage of historical elements",id:"memory-usage-of-historical-elements",level:3},{value:"Handling slow and rogue clients during streaming",id:"handling-slow-and-rogue-clients-during-streaming",level:3},{value:"Approaches to streaming",id:"approaches-to-streaming",level:3},{value:"<strong>Send history first, then stream new events</strong>",id:"send-history-first-then-stream-new-events",level:4},{value:"<strong>Stream new events directly from ring buffer</strong>",id:"stream-new-events-directly-from-ring-buffer",level:4}];function h(e){const n={a:"a",code:"code",del:"del",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Tracking an application lifecycle is not easy in the current YuniKorn setup.\nLogs and statedump data is required to build an overview.\nHistorical tracking of applications is only possible with limited detail per application.\nApplications come and go, we only track what is running and a time limited set of completed applications."}),"\n",(0,s.jsx)(n.p,{children:"Storing detailed tracking information in memory is problematic.\nUnbound growth can cause performance issues or even an out of memory failure of the service.\nThe lessons learned from the YARN days have shown that it is not simple."}),"\n",(0,s.jsx)(n.p,{children:"A conscious choice was also made to keep YuniKorn stateless.\nThe service does not maintain its own datastore for any of its operations.\nAdding a datastore for application and usage tracking will complicate things."}),"\n",(0,s.jsx)(n.p,{children:"Tracking data can be easily generated and made available for external consumption.\nThe design will discuss the option to generate an event stream for applications, queues and nodes to allow external tools to build an overview of the usage pattern."}),"\n",(0,s.jsxs)(n.p,{children:["Work to be tracked under ",(0,s.jsx)(n.a,{href:"https://issues.apache.org/jira/browse/YUNIKORN-1628",children:"YUNIKORN-1628"})]}),"\n",(0,s.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implementation of an event stream for an application, including:"}),"\n",(0,s.jsx)(n.li,{children:"State changes"}),"\n",(0,s.jsx)(n.li,{children:"Asks and allocation changes"}),"\n",(0,s.jsx)(n.li,{children:"Implementation of an event stream for a node, including:"}),"\n",(0,s.jsx)(n.li,{children:"State changes"}),"\n",(0,s.jsx)(n.li,{children:"Allocation changes"}),"\n",(0,s.jsx)(n.li,{children:"Implementation of an event stream for a queue, including:"}),"\n",(0,s.jsx)(n.li,{children:"State changes"}),"\n",(0,s.jsx)(n.li,{children:"Usage changes"}),"\n",(0,s.jsx)(n.li,{children:"Define a REST interface for event retrieval"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"non-goals",children:"Non Goals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Add a data store for the historical data"}),"\n",(0,s.jsx)(n.li,{children:"Display the event information"}),"\n",(0,s.jsx)(n.li,{children:"Rebuild data on recovery"}),"\n",(0,s.jsx)(n.li,{children:"Historical data will not be rebuild"}),"\n",(0,s.jsx)(n.li,{children:"Authentication and Authorisation on the REST interface"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"existing-event-system",children:"Existing Event System"}),"\n",(0,s.jsx)(n.p,{children:"The event system was designed to be far more flexible than the current usage.\nEvents for requests, applications, nodes and queues have been defined.\nMost of those are currently not used.\nThe current event system is built on top of a generic event definition.\nThe scheduler interface defines the event as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"si.EventRecord {\n  Type: recordType,\n  ObjectID: String,\n  GroupID: String,\n  Reason: String,\n  Message: String,\n  TimestampNano: int64,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Events definitions are used in the core and shim.\nThe simplicity of the events will most likely not match the current requirements."}),"\n",(0,s.jsx)(n.p,{children:"As part of the standard scheduling cycle we track details at different levels.\nPrometheus' metrics are tracked for specific changes and updates.\nWe also generate events, REQUEST events, that get passed back into the K8shim to attach to the Kubernetes pods."}),"\n",(0,s.jsx)(n.p,{children:"The current events that get passed back are for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Insufficient Queue Resources"}),": part of the allocation cycle. Called from: ",(0,s.jsx)(n.code,{children:"Application.tryAllocate()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Placeholder Size Mismatch"}),": part of the placeholder replacement cycle. Called from: ",(0,s.jsx)(n.code,{children:"Application.tryPlaceholderAllocate()"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Both events are of the type REQUEST.\nThe K8shim also implements processing of NODE events but there is no code that generates those types of events.\nThe APPLICATION and QUEUE type events are not created or processed."}),"\n",(0,s.jsxs)(n.p,{children:["The event system was added as part of ",(0,s.jsx)(n.a,{href:"https://issues.apache.org/jira/browse/YUNIKORN-42",children:"YUNIKORN-42"}),".\nThe jira contains a simple design document for the event system.\nIt only was implemented for events that we could not at that point get in any other way: ",(0,s.jsx)(n.a,{href:"https://docs.google.com/document/d/1aKfY6wnBPCyBl03UfmMHbTSpabAbfxtsHT2KzOgEOQs/edit",children:"design v2"}),".\nThe original thought was a more generic event system.\nIt would relate everything back to either a pod or the YuniKorn CRD and was focussed on diagnostics and troubleshooting in general: ",(0,s.jsx)(n.a,{href:"https://docs.google.com/document/d/19iMkLJGVwTSq9OfV9p75wOobJXAxR_CRo4YzSRG_Pzw/edit#heading=h.worp3vfnqgtn",children:"design v1"}),".\nLinking it all back to a specific pod is The YuniKorn CRD is not used at this point in time."]}),"\n",(0,s.jsx)(n.h3,{id:"scheduler-integration",children:"Scheduler integration"}),"\n",(0,s.jsx)(n.p,{children:"When the event system was designed the whole purpose was to allow out of band processing of the events from the scheduling cycle.\nThe events are generated during the scheduling cycle and processed asynchronously in the event system."}),"\n",(0,s.jsx)(n.p,{children:"A channel is used for collecting the events during the scheduling cycle.\nThe scheduler generates an event and adds it for processing to the channel.\nAfter the placement of the event on the channel the scheduler proceeds with the normal cycle.\nProcessing of the events does not, and must not, block the scheduling cycle."}),"\n",(0,s.jsx)(n.p,{children:"This part of the event system must be maintained as it will guarantee the performance of the scheduler."}),"\n",(0,s.jsx)(n.h3,{id:"event-storage",children:"Event storage"}),"\n",(0,s.jsxs)(n.p,{children:["All events that have been sent to the channel are read from the channel and placed in a temporary store for publishing.\nThe store is a simple map with the key of the ",(0,s.jsx)(n.em,{children:"ObjectID"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Some of the assumptions in the event store however make it not directly usable for the purpose as described here.\nThe main limitation is that there can only be one event in the channel per ",(0,s.jsx)(n.em,{children:"ObjectID"}),".\nThe newest one is kept, the older one is dropped when a new event comes in.\nThis however does not mean the code already available with minor changes could be re-used for this purpose."]}),"\n",(0,s.jsx)(n.h3,{id:"publishing-events",children:"Publishing events"}),"\n",(0,s.jsx)(n.p,{children:"The current event system uses a push system for event publishing.\nThe event system allows the creation of multiple event publishers.\nThere is no implementation or design for a pull system, like for instance a REST based interface."}),"\n",(0,s.jsx)(n.p,{children:"Currently, there is only an event publisher for a shim defined.\nThis push system will send all the events that have been collected during the push interval to the shim.\nAll events that are pushed will be removed from the store.\nThis keeps the size of the store to a minimum."}),"\n",(0,s.jsx)(n.p,{children:"There is no filtering or post-processing of events implemented.\nEach event stored in the store is forwarded to the shim when the publisher runs.\nSee limitations of the store mentioned above.\nIn the earlier design a level filter was described.\nThat level was never part of the follow-up design, not in the events and not in the processing."}),"\n",(0,s.jsx)(n.h2,{id:"event-system-updates",children:"Event System Updates"}),"\n",(0,s.jsx)(n.p,{children:"The currently defined events are not a fit for the system we want and need.\nSince the events are only used between the core and the K8shim via the publisher we do not need to maintain backwards compatibility.\nChanges can be made to the messages as we do not currently expose the message to the outside."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"message"})," and ",(0,s.jsx)(n.em,{children:"reason"})," fields are currently not properly used.\nThe content of the two overlaps.\nThe message in both cases contains the reason, in slightly different wording.\nWe do not need both."]}),"\n",(0,s.jsx)(n.h3,{id:"event-description",children:"Event description"}),"\n",(0,s.jsxs)(n.p,{children:["We are also missing two fields to allow an extended usage for historical tracking: the ",(0,s.jsx)(n.em,{children:"resource"})," and the ",(0,s.jsx)(n.em,{children:"change type"}),".\nBased on that the new message that would allow using the event system for tracking historical change would be:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"si.EventRecord {\n  Type: eventRecordType,\n  ChangeType: eventChangeType,\n  ChangeDetail: eventChangeDetail,\n  TimestampNano: int64,\n  ObjectID: String,\n  ReferenceID: String,\n  Resource: si.Resource,\n  Message: String,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The existing ",(0,s.jsx)(n.em,{children:"GroupID"})," has been renamed to ",(0,s.jsx)(n.em,{children:"ReferenceID"}),". The\n",(0,s.jsx)(n.em,{children:"ReferenceID"})," is the identification of the second object for the event.\nAs an example that would be the Allocation UUID for a new allocation\nadded to an application, request or node. For the queue that would be\nthe application ID."]}),"\n",(0,s.jsx)(n.p,{children:"Note that the order of the attributes in the final definition might be\ndifferent as we do not reuse names and IDs in the messages."}),"\n",(0,s.jsx)(n.h3,{id:"event-types",children:"Event types"}),"\n",(0,s.jsxs)(n.p,{children:["By keeping the event type for REQUESTS we can still fulfil the original\ndesign of YUNIKORN-42. The current enumeration for the ",(0,s.jsx)(n.em,{children:"eventRecordType"}),"\nwould not change. Definition of the eventRecordType enumeration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"UNKNOWN = 0\nREQUEST = 1\nAPP = 2\nNODE = 3\nQUEUE = 4\n"})}),"\n",(0,s.jsx)(n.h3,{id:"change-types",children:"Change types"}),"\n",(0,s.jsx)(n.p,{children:"The additional change type that is added allows us to track the type of\nchange. Depending on the content of the other fields it provides the\npossibility to track all changes we need to track. Definition of the\neventChangeType enumeration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"NONE = 0\nSET = 1\nADD = 2\nREMOVE = 3\n"})}),"\n",(0,s.jsx)(n.h3,{id:"change-details",children:"Change details"}),"\n",(0,s.jsx)(n.p,{children:"Change detail provides more on the reason for the event. The change\ndetail is an enumerated value linked to the event types."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"DETAILS_NONE = 0\n\nREQUEST_CANCEL = 100 // Request cancelled by the RM\nREQUEST_ALLOC = 101 // Request allocated\nREQUEST_TIMEOUT = 102 // Request cancelled due to timeout\n\nAPP_ALLOC = 200 // Allocation changed\nAPP_REQUEST = 201 // Request changed\nAPP_REJECT = 202 // Application rejected on create\nAPP_NEW = 203 // Application added with state new\nAPP_ACCEPTED = 204 // State change to accepted\nAPP_STARTING = 205 // State change to starting\nAPP_RUNNING = 206 // State change to running\nAPP_COMPLETING = 207 // State change to completing\nAPP_COMPLETED = 208 // State change to completed\nAPP_FAILING = 209 // State change to failing\nAPP_FAILED = 210 // State change to failed\nAPP_RESUMING = 211; // State change to resuming\nAPP_EXPIRED = 212; // State change to expired\n\nNODE_DECOMISSION = 300 // Node removal\nNODE_READY = 301 // Node ready state change\nNODE_SCHEDULABLE = 302 // Node schedulable state change (cordon)\nNODE_ALLOC = 303 // Allocation changed\nNODE_CAPACITY = 304 // Capacity changed\nNODE_OCCUPIED = 305 // Occupied resource changed\nNODE_RESERVATION = 306; // Reservation/unreservation occurred\n\nQUEUE_CONFIG = 400 // Managed queue update or removal\nQUEUE_DYNAMIC = 401 // Dynamic queue update or removal\nQUEUE_TYPE = 402 // Queue type change\nQUEUE_MAX = 403 // Max resource changed\nQUEUE_GUARANTEED = 404 // Guaranteed resource changed\nQUEUE_APP = 405 // Application changed\nQUEUE_ALLOC = 406 // Allocation changed\nALLOC_CANCEL = 500 // Allocation cancelled by the RM\nALLOC_PREEMPT = 501 // Allocation preempted by the core\nALLOC_TIMEOUT = 502 // Allocation cancelled due to timeout\nALLOC_REPLACED = 503 // Allocation replacement (placeholder)\nALLOC_NODEREMOVED = 504 // Allocation cancelled, node removal\n"})}),"\n",(0,s.jsx)(n.h3,{id:"content-definition",children:"Content definition"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"eventRecordType"})," defines the object that the ",(0,s.jsx)(n.em,{children:"ObjectID"})," points to.\nThe content of the ",(0,s.jsx)(n.em,{children:"ReferenceID"})," depends on two things:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Change type"}),"\n",(0,s.jsxs)(n.li,{children:["Object type inferred by the ",(0,s.jsx)(n.em,{children:"eventRecordType"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For an object of type application it would not make sense to have the reference point to another application etc.\nAt this point the following mapping for ",(0,s.jsx)(n.em,{children:"ReferenceID"})," is assumed:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event Type"}),(0,s.jsx)(n.th,{children:"Reference ID"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REQUEST"}),(0,s.jsx)(n.td,{children:"ApplicationID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"Allocation UUID or Request UUID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"Allocation UUID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"ApplicationID or Allocation UUID"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"eventChangeType"})," Is NONE or SET the ",(0,s.jsx)(n.em,{children:"ReferenceID"})," is always empty.\nThe exception is for the REQUEST as in that case the change type NONE has an application ID set.\nThis special case is used to implement the existing functionality of the event system: sending events to the shim."]}),"\n",(0,s.jsxs)(n.p,{children:["The APP record type supports Request IDs and Allocation UUIDs to be set in the ",(0,s.jsx)(n.em,{children:"ReferenceID"}),".\nThe type of ID that is referenced is defined by the ",(0,s.jsx)(n.em,{children:"ChangeDetail"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The QUEUE record type supports application IDs and Allocation UUIDs to be set in the ",(0,s.jsx)(n.em,{children:"ReferenceID"}),".\nIndividual allocations are not tracked on the queue.\nHowever, we leave that option open for the event system at this point."]}),"\n",(0,s.jsxs)(n.p,{children:["For the QUEUE if ",(0,s.jsx)(n.em,{children:"ReferenceID"})," and ",(0,s.jsx)(n.em,{children:"Resource"})," are set, the ID points to an allocation.\nThis can only happen if the ",(0,s.jsx)(n.em,{children:"ChangeDetail"})," is set to QUEUE_ALLOC."]}),"\n",(0,s.jsxs)(n.p,{children:["If only the ",(0,s.jsx)(n.em,{children:"ReferenceID"})," is set it points to an application.\nThis can only happen if the ",(0,s.jsx)(n.em,{children:"ChangeDetail"})," is set to QUEUE_APP.\nBoth cases can use the same ",(0,s.jsx)(n.em,{children:"eventChangeType"}),", add or remove an allocation or an application from a queue."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"Resource"})," that is part of any event would be the size of the resource for that change.\nThe interpretation depends on the ",(0,s.jsx)(n.em,{children:"eventChangeType"}),".\nFor a SET it is the absolute value. For the ADD and REMOVE it is the positive delta on the existing tracked value.\nThe ",(0,s.jsx)(n.em,{children:"Resource"})," is always a positive value."]}),"\n",(0,s.jsx)(n.h2,{id:"event-storage-1",children:"Event storage"}),"\n",(0,s.jsxs)(n.p,{children:["The storage of events needs to be updated to allow multiple events to be stored for an ",(0,s.jsx)(n.em,{children:"ObjectID"}),".\nThis is required as one object could trigger multiple events in a short time and all are important to track.\nThis will require a change from a map based storage to a different store or a change in the key used for the map."]}),"\n",(0,s.jsx)(n.p,{children:"The simplest solution might be a slice of pointers to events.\nThe slice has a configurable, limited set of entries.\nThe slice is accessed and maintained as a ring buffer.\nThis will prevent an unlimited growth of the schedulers memory requirements.\nDuring the implementation a decision will be made which configuration, time; count or both, for limiting the size will be supported."}),"\n",(0,s.jsx)(n.p,{children:"Nil, or empty, events will not be added to the storage.\nHowever, no publisher must assume that while processing events retrieved from the buffer and needs to handle nil references.\nA location in the buffer could contain a nil pointer and must be skipped while iterating over the buffer.\nIf a publisher gets a nil event pointer it must not crash and proceed as normal."}),"\n",(0,s.jsxs)(n.p,{children:["The current design will use two stores: one for external retrieval and one for the shim events.\nA filter at the receiving end will be created.\nThe shim events will then be processed as per the existing implementation.\nThe new events will be stored and managed as per this design document in ",(0,s.jsx)(n.a,{href:"#shim-events",children:"SHIM events"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"publishing-events-1",children:"Publishing events"}),"\n",(0,s.jsx)(n.p,{children:"Events are currently not post processed and all events are sent to the shim.\nWith the newly added events the publishing needs to be split into two separate loops."}),"\n",(0,s.jsx)(n.h4,{id:"shim-events",children:"SHIM events"}),"\n",(0,s.jsx)(n.p,{children:"Current functionality will be supported as described above.\nUpdates are required as the content of the events has changed.\nThe same event type will be generated.\nThe same processing mechanism will be used."}),"\n",(0,s.jsx)(n.p,{children:"As part of processing events REQUEST type events are special.\nThe REQUEST type with the change type NONE has an application ID set and is only sent as an event to the shim.\nThese events must not be made available by any other publishers and are stored in a separate ring buffer.\nAfter the event is sent to the shim the reference to the event in the buffer is cleared, replaced with a nil."}),"\n",(0,s.jsx)(n.h4,{id:"rest",children:"REST"}),"\n",(0,s.jsx)(n.p,{children:"The REST service that is currently running can be reused for exposing the events.\nProposal is to add a new endpoint to the HTTP service.\nThe REST endpoint servicing the event data should be a new end point."}),"\n",(0,s.jsx)(n.p,{children:"Based on the current REST api definition the data exposed in the following new endpoint will be added to expose the events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"/ws/v1/events/batch\n"})}),"\n",(0,s.jsx)(n.p,{children:"The design will not define a sophisticated interface for querying events, like filtering, grouping, etc.\nThis is a deliberate decision.\nSuch an API can encourage bad practices later on.\nThat should be done in a separate application which fetches the events from YuniKorn and persists them in a permanent storage and offers a more feature rich REST/query interface.\nThis would be similar to what already exists in Apache Hadoop like Job History Server or Application Timeline Service."}),"\n",(0,s.jsx)(n.p,{children:"As mentioned earlier in this document, such an application is not in the scope."}),"\n",(0,s.jsxs)(n.p,{children:["The batch endpoint, by default, returns a limited number of events.\nThe number of events to return can be specifically set via the query parameter ",(0,s.jsx)(n.em,{children:"count"}),".\nIf the requested ",(0,s.jsx)(n.em,{children:"count"})," is larger than the available number of events all events are returned."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"/ws/v1/events/batch?count=100\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To prevent a DOS attack the maximum value of ",(0,s.jsx)(n.em,{children:"count"})," might be limited as part of the implementation."]}),"\n",(0,s.jsxs)(n.p,{children:["The second query parameter that will be supported is ",(0,s.jsx)(n.em,{children:"start"}),".\nThis specifies the start ID of the first event returned.\nEvery event is assigned a unique id starting from 0.\nThe ring buffer maintains the current available highest and lowest ID.\nIf ",(0,s.jsx)(n.em,{children:"start"})," refers to an ID which doesn't exist in the buffer, then an empty response is returned from the server, with ",(0,s.jsx)(n.em,{children:"LowestID"})," and ",(0,s.jsx)(n.em,{children:"HighestID"})," properly filled:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"lines",children:'{\n    "InstanceUUID": "b4751b7d-a1a3-4431-bb68-bff896adb9c2",\n    "LowestID": 1100,\n    "HighestID": 11000,\n    "EventRecords": null\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"In the next request, start should be defined as 1100."}),"\n",(0,s.jsxs)(n.p,{children:["In the response, the ",(0,s.jsx)(n.em,{children:"InstanceUUID"})," field shows the unique instance ID.\nSince YuniKorn is stateless, the generated ID for an event is not saved anywhere.\nIf an event consumer saves the events to a backend database, it makes it possible to distinguish between events with the same ID.\nAlso, clients can easily detect that YuniKorn was restarted."]}),"\n",(0,s.jsx)(n.h4,{id:"streaming",children:"Streaming"}),"\n",(0,s.jsx)(n.p,{children:'Streaming allows the user to see a continuous stream of events as they are occurring.\nThis can be very useful if we want to trace the state changes inside YuniKorn for a longer amount of time.\nThe REST interface can return the last "n" amount of events that occurred in a certain timeframe, but it will always be limited.\nWe can only increase the number of events at the expense of memory usage, which might not be acceptable in certain environments.'}),"\n",(0,s.jsx)(n.p,{children:'Although streaming is a nice feature, we do not consider it as a "must have", at least not in the first version of the history tracking.\nThis is because it\'s more complicated in nature: it maintains an open HTTP connection towards the client which makes it stateful.\nThere are ordering and memory usage concerns&considerations.\nWe need to make sure that rogue clients cannot abuse it.\nTherefore, the first release of history tracking focuses on the batch interface.'}),"\n",(0,s.jsx)(n.p,{children:"Streaming needs to coexist beside the current REST api.\nA separate endpoint must be exposed for the event stream:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"/ws/v1/events/stream\n"})}),"\n",(0,s.jsx)(n.p,{children:"Streaming can be similar to how it's implemented inside Kubernetes informers.\nThe API server keeps the connection alive and sends the necessary events about pods, nodes, configmaps, etc.\nThe incoming data stream is decoded by the listeners.\nEvent processing on the client side is not part of this design."}),"\n",(0,s.jsxs)(n.p,{children:["At this point we do not provide endpoints for consumers to stream a specific event type as defined in ",(0,s.jsx)(n.a,{href:"#event-types",children:"Event types"}),".\nThis could be made available via separate endpoints in the future following the same design as for ",(0,s.jsx)(n.em,{children:"batch"})," specification"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"stream"})," endpoint does not take any query parameters.\nThe consumer must allow for more than one (1) event to be sent in one response.\nNo information besides the events will be sent in the response."]}),"\n",(0,s.jsx)(n.p,{children:"As an example below the approximate output for the stream endpoint for two events"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'[\n  {\n  "type": 2,\n    "changeType": 1,\n    "changeDetail": 203,\n    "timestamp": 1649167576110750000,\n    "objectID": "spark-app-1"\n  },\n  {\n    "type": 4,\n    "changeType": 2,\n    "changeDetail": 405,\n    "timestamp": 1649167576110754000,\n    "objectID": "root.spark",\n    "referenceID": "spark-app-1"\n  }\n]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"event-overview",children:"Event overview"}),"\n",(0,s.jsx)(n.h3,{id:"generic-events",children:"Generic events"}),"\n",(0,s.jsxs)(n.p,{children:["The following events are generated for streaming and REST consumers, meaning that they will not be sent to the shim.\nThis is based on the description of the ",(0,s.jsx)(n.a,{href:"#event-system-updates",children:"Event System Updates"})," earlier in this document.\nIt serves as a reference for the core scheduler actions that will trigger the event."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event type"}),(0,s.jsx)(n.th,{children:"Change type"}),(0,s.jsx)(n.th,{children:"Change details"}),(0,s.jsx)(n.th,{children:"Reference type"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"DETAILS_NONE"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"New application added"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"APP_ALLOC"}),(0,s.jsx)(n.td,{children:"AllocationID"}),(0,s.jsx)(n.td,{children:"Successful allocation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"APP_REQUEST"}),(0,s.jsx)(n.td,{children:"RequestID"}),(0,s.jsx)(n.td,{children:"Incoming resource request (pod)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"DETAILS_NONE"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Normal removal of application"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"APP_REJECT"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Application rejected"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"ALLOC_CANCEL"}),(0,s.jsx)(n.td,{children:"AllocationID"}),(0,s.jsx)(n.td,{children:"Normal removal requested by the shim"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"ALLOC_TIMEOUT"}),(0,s.jsx)(n.td,{children:"AllocationID"}),(0,s.jsx)(n.td,{children:"Timeout"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"ALLOC_REPLACED"}),(0,s.jsx)(n.td,{children:"AllocationID"}),(0,s.jsx)(n.td,{children:"Replacement (placeholder)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"ALLOC_PREEMPT"}),(0,s.jsx)(n.td,{children:"AllocationID"}),(0,s.jsx)(n.td,{children:"Preemption triggered"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"ALLOC_NODEREMOVED"}),(0,s.jsx)(n.td,{children:"AllocationID"}),(0,s.jsx)(n.td,{children:"Removal triggered by node removal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"APP_REQUEST"}),(0,s.jsx)(n.td,{children:"RequestID"}),(0,s.jsx)(n.td,{children:"Normal removal requested by the shim"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"REQUEST_TIMEOUT"}),(0,s.jsx)(n.td,{children:"RequestID"}),(0,s.jsx)(n.td,{children:"Timeout (placeholder)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"REQUEST_CANCEL"}),(0,s.jsx)(n.td,{children:"RequestID"}),(0,s.jsx)(n.td,{children:"Removal triggered by application removal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_NEW"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: New"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_ACCEPTED"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Accepted"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_STARTING"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Starting"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_RUNNING"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Running"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_COMPLETING"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Completing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_COMPLETED"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Completed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_FAILING"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Failing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_FAILED"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Failed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_RESUMING"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Resuming"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"APP"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"APP_EXPIRED"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"State change: Expired"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"DETAILS_NONE"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"New node added to the cluster"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"NODE_ALLOC"}),(0,s.jsx)(n.td,{children:"AllocationID"}),(0,s.jsx)(n.td,{children:"Successful allocation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"NODE_DECOMISSION"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Removal requested by the shim"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"NODE_ALLOC"}),(0,s.jsx)(n.td,{children:"AllocationID"}),(0,s.jsx)(n.td,{children:"Normal allocation removal requested by the shim"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"NODE_READY"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:'Update "ready" status'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"NODE_SCHEDULABLE"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:'Update "schedulable" status'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"NODE_CAPACITY"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Update node capacity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"NODE_OCCUPIED"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Update occupied resources"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"NODE_RESERVATION"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Add reservation to a node"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NODE"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"NODE_RESERVATION"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Remove reservation from a node"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"DETAILS_NONE"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Adding new configured queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"QUEUE_DYNAMIC"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Adding new dynamic queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"ADD"}),(0,s.jsx)(n.td,{children:"QUEUE_APP"}),(0,s.jsx)(n.td,{children:"ApplicationID"}),(0,s.jsx)(n.td,{children:"Application added"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"DETAILS_NONE"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Removing configured queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"QUEUE_DYNAMIC"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Removing dynamic queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"REMOVE"}),(0,s.jsx)(n.td,{children:"QUEUE_APP"}),(0,s.jsx)(n.td,{children:"ApplicationID"}),(0,s.jsx)(n.td,{children:"Application removed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"QUEUE_MAX"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Max resource changed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"QUEUE_GUARANTEED"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Guaranteed resource changed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUE"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"QUEUE_TYPE"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Queue type change(parent/leaf)"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"shim-events-1",children:"Shim events"}),"\n",(0,s.jsx)(n.p,{children:"Shim events are a type of REQUEST and the application ID is set.\nRight now we send only two types of events to the shim, both of which are originated from the application:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Insufficient resources in the queue for a request"}),"\n",(0,s.jsx)(n.li,{children:"Real allocation is larger than placeholder"}),"\n"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event type"}),(0,s.jsx)(n.th,{children:"Change type"}),(0,s.jsx)(n.th,{children:"Change details"}),(0,s.jsx)(n.th,{children:"Reference type"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REQUEST"}),(0,s.jsx)(n.td,{children:"NONE"}),(0,s.jsx)(n.td,{children:"DETAILS_NONE"}),(0,s.jsx)(n.td,{children:"ApplicationID"}),(0,s.jsx)(n.td,{children:"New application added"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REQUEST"}),(0,s.jsx)(n.td,{children:"NONE"}),(0,s.jsx)(n.td,{children:"DETAILS_NONE"}),(0,s.jsx)(n.td,{children:"ApplicationID"}),(0,s.jsx)(n.td,{children:"Successful allocation"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["As part of the design we anticipate the following configuration to be added for the event storage and retrieval.\nAll settings will have the shared prefix: ",(0,s.jsx)(n.em,{children:"service.event"}),".\nAll the mentioned settings will require a restart of the scheduler for updates to take effect."]}),"\n",(0,s.jsx)(n.p,{children:"The following settings will be added to the system:"}),"\n",(0,s.jsx)(n.p,{children:"A flag to enable or disable sending request events to the K8shim.\nThis externalises the current setting that needs a recompile of the code.\nThe default mirrors the current default in the code."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Name: ",(0,s.jsx)(n.strong,{children:"requestEventsEnabled"})]}),"\n",(0,s.jsxs)(n.li,{children:["Allowed values: all boolean values will be converted into a boolean using ParseBool as defined in the ",(0,s.jsx)(n.code,{children:"strconv"})," package",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Default value: false"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A flag to enable or disable event collection in the system.\nThe default is enabled for the tracking events."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Name: ",(0,s.jsx)(n.strong,{children:"trackingEventsEnabled"})]}),"\n",(0,s.jsxs)(n.li,{children:["Allowed values: all boolean values will be converted into a boolean using ParseBool as defined in the ",(0,s.jsx)(n.code,{children:"strconv"})," package."]}),"\n",(0,s.jsx)(n.li,{children:"Default value: true"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Size of the store for events that will be sent to the shim, request events.\nNote that setting a size of 0 effectively turns off the request event system."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Name: ",(0,s.jsx)(n.strong,{children:"requestStoreCapacity"})]}),"\n",(0,s.jsxs)(n.li,{children:["Allowed values: integer value that can be converted into a 32-bit integer using ParseUint as defined in the ",(0,s.jsx)(n.code,{children:"strconv"})," package",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Default value: 1,000"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The number of events to store in the ring buffer.\nThis number defines the size of the ring buffer and thus the memory impact the event storage will have on the scheduler.\nNote that setting a size of 0 effectively turns off the event collection system."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Name: ",(0,s.jsx)(n.strong,{children:"ringBufferCapacity"})]}),"\n",(0,s.jsxs)(n.li,{children:["Allowed values: integer value that can be converted into a 32-bit integer using ParseUint as defined in the ",(0,s.jsx)(n.code,{children:"strconv"})," package"]}),"\n",(0,s.jsx)(n.li,{children:"Default value: 100,000"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The maximum number of events to return in one REST response.\nThe maximum that could be returned is limited to the ring buffer capacity.\nHowever, preparing a large response the size of the whole ring buffer could cause large peaks in the schedulers memory usage.\nThis setting should be used to prevent these peaks."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Name: ",(0,s.jsx)(n.strong,{children:"RESTResponseSize"})]}),"\n",(0,s.jsxs)(n.li,{children:["Allowed values: integer value that can be converted into a 32-bit integer using ParseUint as defined in the ",(0,s.jsx)(n.code,{children:"strconv"})," package"]}),"\n",(0,s.jsx)(n.li,{children:"Default value: 10,000"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance considerations"}),"\n",(0,s.jsx)(n.h3,{id:"memory-usage-of-historical-elements",children:"Memory usage of historical elements"}),"\n",(0,s.jsx)(n.p,{children:"We need to estimate how many elements we can expect to be generated with different pod churn rates on a daily basis.\nQueue and node events are much rarer, so they are not accounted for.\nWe also ignore potential failures and scheduling errors."}),"\n",(0,s.jsx)(n.p,{children:"An application undergoes state transitions, so the following events are generated:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Add new application"}),"\n",(0,s.jsx)(n.li,{children:"State change: New"}),"\n",(0,s.jsx)(n.li,{children:"State change: Accepted"}),"\n",(0,s.jsx)(n.li,{children:"State change: Starting"}),"\n",(0,s.jsx)(n.li,{children:"State change: Running"}),"\n",(0,s.jsx)(n.li,{children:"State change: Completing"}),"\n",(0,s.jsx)(n.li,{children:"State change: Completed"}),"\n",(0,s.jsx)(n.li,{children:"Allocation changed"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Pod (request) events:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Incoming allocation request"}),"\n",(0,s.jsx)(n.li,{children:"Successful allocation on a node"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Pod (request) events with gang scheduling:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Incoming resource request"}),"\n",(0,s.jsx)(n.li,{children:"Successful allocation on a node"}),"\n",(0,s.jsx)(n.li,{children:"Replace event for placeholder"}),"\n"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Number of pods"}),(0,s.jsx)(n.th,{children:"Number of apps"}),(0,s.jsx)(n.th,{children:"Pods per app"}),(0,s.jsx)(n.th,{children:"Job type"}),(0,s.jsx)(n.th,{children:"Events per app"}),(0,s.jsx)(n.th,{children:"Events per pod"}),(0,s.jsx)(n.th,{children:"\u2211 apps"}),(0,s.jsx)(n.th,{children:"\u2211 pods"}),(0,s.jsx)(n.th,{children:"\u2211 events"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"150k"}),(0,s.jsx)(n.td,{children:"1500"}),(0,s.jsx)(n.td,{children:"100"}),(0,s.jsx)(n.td,{children:"normal"}),(0,s.jsx)(n.td,{children:"200 + 7"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"310k (1500 * 207)"}),(0,s.jsx)(n.td,{children:"300k (2 * 150k)"}),(0,s.jsx)(n.td,{children:"610k"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"150k"}),(0,s.jsx)(n.td,{children:"1500"}),(0,s.jsx)(n.td,{children:"100"}),(0,s.jsx)(n.td,{children:"gang"}),(0,s.jsx)(n.td,{children:"300 + 7"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"460k (1500 * 307)"}),(0,s.jsx)(n.td,{children:"450k (3 * 150k)"}),(0,s.jsx)(n.td,{children:"910k"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"300k"}),(0,s.jsx)(n.td,{children:"3000"}),(0,s.jsx)(n.td,{children:"100"}),(0,s.jsx)(n.td,{children:"normal"}),(0,s.jsx)(n.td,{children:"200 + 7"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"621k (3000 * 207)"}),(0,s.jsx)(n.td,{children:"600k (2 * 300k)"}),(0,s.jsx)(n.td,{children:"1,2M"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"300k"}),(0,s.jsx)(n.td,{children:"3000"}),(0,s.jsx)(n.td,{children:"100"}),(0,s.jsx)(n.td,{children:"gang"}),(0,s.jsx)(n.td,{children:"300 + 7"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"921k (3000 * 307)"}),(0,s.jsx)(n.td,{children:"900k (3 * 300k)"}),(0,s.jsx)(n.td,{children:"1,8M"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"On a busy cluster with 150,000 - 300,000 pods per day, we can expect the number of events generated to be around 600k - 1,8M (depending on the scheduling style)."}),"\n",(0,s.jsx)(n.p,{children:"If we want to retain the events for 5 days, we need to store 9 million events in the worst case and 3 million in the best case."}),"\n",(0,s.jsx)(n.p,{children:"With 9 million objects in the memory, it is also critical to estimate how much extra memory usage is expected from YuniKorn with different kinds of data structures:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["slice of pointers to si.EventRecord objects ",(0,s.jsx)(n.code,{children:"[]*si.EventRecord"})]}),"\n",(0,s.jsxs)(n.li,{children:["slice of si.EventRecord objects ",(0,s.jsx)(n.code,{children:"[]si.EventRecord"})]}),"\n",(0,s.jsxs)(n.li,{children:["slice of a memory-optimised data type ",(0,s.jsx)(n.code,{children:"[]internalRecord"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"As the name suggests, internalRecord type would only be available inside the ring buffer.\nIt's used together with string interning to save memory caused by repeated strings like IDs (application ID, ask ID, allocation ID, etc.).\nThere are various interning libraries in Go, but removing elements is not possible from them.\nWe need to create our own, so we can track the number of references per string."}),"\n",(0,s.jsxs)(n.p,{children:["The following table summarizes memory usage and GC time, depending on how we store the events.\nThe test was executed multiple times to get averages and ranges.\nThe slice was created once, then an index variable was increased for each record, so the built-in ",(0,s.jsx)(n.code,{children:"append()"})," function was not used."]}),"\n",(0,s.jsx)(n.p,{children:"The results clearly indicate two things:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"having millions of pointers has negative performance on both the memory usage and GC load"}),"\n",(0,s.jsx)(n.li,{children:"batch workloads inherently have a lot of repeated strings, so interning makes a noticeable difference"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The GC detects pointers, since it has to follow them to walk the object graph to identify unreferenced objects.\nIf elements in the slice are pointers, then those allocations are scattered all around the heap (bad locality) with header information added by the allocator.\nThis reduces memory access times and increases the amount of the data that is allocated."}),"\n",(0,s.jsx)(n.p,{children:"In the test, the assumption was 100 pods per application.\nIn real life, this value might be different, most likely it's lower.\nThe lower the value, the smaller the advantage of the interning - on the extreme, every application consists of only one pod.\nBut even with only 30 pods per application, it has value - more modest, 20-30% reductions are not negligible when storing millions of elements."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Object type"}),(0,s.jsx)(n.th,{children:"Number of elements"}),(0,s.jsx)(n.th,{children:"Increased memory usage*"}),(0,s.jsx)(n.th,{children:"GC time**"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]*si.EventRecord"}),(0,s.jsx)(n.td,{children:"3M"}),(0,s.jsx)(n.td,{children:"805 MiB"}),(0,s.jsx)(n.td,{children:"85-105 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]si.EventRecord"}),(0,s.jsx)(n.td,{children:"3M"}),(0,s.jsx)(n.td,{children:"437 MiB"}),(0,s.jsx)(n.td,{children:"41-55 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]internalRecord"}),(0,s.jsx)(n.td,{children:"3M"}),(0,s.jsx)(n.td,{children:"211 MiB"}),(0,s.jsx)(n.td,{children:"5-16 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]*si.EventRecord"}),(0,s.jsx)(n.td,{children:"6M"}),(0,s.jsx)(n.td,{children:"1595 MiB"}),(0,s.jsx)(n.td,{children:"160-200 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]si.EventRecord"}),(0,s.jsx)(n.td,{children:"6M"}),(0,s.jsx)(n.td,{children:"856 MiB"}),(0,s.jsx)(n.td,{children:"75-110 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]internalRecord"}),(0,s.jsx)(n.td,{children:"6M"}),(0,s.jsx)(n.td,{children:"404 MiB"}),(0,s.jsx)(n.td,{children:"10-30 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]*si.EventRecord"}),(0,s.jsx)(n.td,{children:"9M"}),(0,s.jsx)(n.td,{children:"2380 MiB"}),(0,s.jsx)(n.td,{children:"270-320 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]si.EventRecord"}),(0,s.jsx)(n.td,{children:"9M"}),(0,s.jsx)(n.td,{children:"1280 MiB"}),(0,s.jsx)(n.td,{children:"116-150 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"[]internalRecord"}),(0,s.jsx)(n.td,{children:"9M"}),(0,s.jsx)(n.td,{children:"593 MiB"}),(0,s.jsx)(n.td,{children:"16-33 ms"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:'* "Sys" metrics returned by the Go runtime'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["** measured by the execution time of ",(0,s.jsx)(n.code,{children:"runtime.GC()"})]})}),"\n",(0,s.jsx)(n.h3,{id:"handling-slow-and-rogue-clients-during-streaming",children:"Handling slow and rogue clients during streaming"}),"\n",(0,s.jsx)(n.p,{children:"It's possible to overwhelm YuniKorn with streaming or execute a DoS attack."}),"\n",(0,s.jsx)(n.p,{children:"The first thing we need to address is a rogue client which simply stops reading on the receiver side from the TCP socket.\nEventually writes will block in YuniKorn.\nIf we use channels and per-client goroutines, this should not be an issue - we can always check if the buffer is full using the built-in len() function.\nIf this happens, we can just drop the connection.\nIn some situations, the buffer is expected to be full, for example, when sending history.\nIt's always faster to send out a lot of existing objects, so we can expect the buffer to get full at times.\nThis can be solved by repeatedly checking the rate of writes - if it falls below a certain threshold, then again, we just drop the connection with an error message."}),"\n",(0,s.jsx)(n.p,{children:"We can also limit the number of concurrent streaming connections and historical objects to send, e.g. we simply won't serve requests which would result in sending millions of elements."}),"\n",(0,s.jsx)(n.p,{children:"Note that it's still possible to deny the service from legitimate users because YuniKorn lacks authentication on the REST interface.\nThis will be solved in the future."}),"\n",(0,s.jsx)(n.h3,{id:"approaches-to-streaming",children:"Approaches to streaming"}),"\n",(0,s.jsx)(n.p,{children:"When a client requests a stream of events, it can define how many past events it wants to receive.\nThis is necessary because when YuniKorn starts up, it's not possible to connect immediately.\nIt can be important for certain users to save the state of YuniKorn on an external storage completely from the start."}),"\n",(0,s.jsx)(n.p,{children:"Sending the historical events must be separated from the new events that are constantly occurring in the system, that is, old and current events must not interleave.\nFor example: we want a stream of old and new events, this means:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We're currently at ",(0,s.jsxs)(n.em,{children:["event",(0,s.jsx)(n.del,{children:"n"})]})]}),"\n",(0,s.jsxs)(n.li,{children:["Send out events from ",(0,s.jsxs)(n.em,{children:["event",(0,s.jsx)(n.del,{children:"0"})]})," all the way up to ",(0,s.jsxs)(n.em,{children:["event",(0,s.jsx)(n.del,{children:"n"})]})]}),"\n",(0,s.jsxs)(n.li,{children:["In the meantime, ",(0,s.jsx)(n.em,{children:"k"})," number of events have been generated"]}),"\n",(0,s.jsxs)(n.li,{children:["Therefore, send events up to event",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.del,{children:"n+k"})})," until we're caught up completely"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"send-history-first-then-stream-new-events",children:(0,s.jsx)(n.strong,{children:"Send history first, then stream new events"})}),"\n",(0,s.jsxs)(n.p,{children:["The first approach is to retrieve the objects from the ring buffer and start to send them on a channel to the receiver.\nThere is a separate buffered channel for new events with capacity ",(0,s.jsx)(n.em,{children:"localBufferSize"}),".\nAs soon as we finish sending the history, we switch to this channel and relay events from it towards the client."]}),"\n",(0,s.jsx)(n.p,{children:"We can express this with the following pseudocode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"consumerEventLoop(elementCount) {\n    local = initLocalEventChannel(localBufferSize)\n    // send history\n    history := ringbuffer.getHistory(elementCount)\n    foreach h : history {\n        receiver <- h\n    }\n    // bridge new events\n    foreach e : <-local {\n        receiver <- e\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The publisher logic is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'publishEvent(event) {\n    foreach c : localChannels {\n        if len(c) == localBufferSize { // local buffer full?\n            closeChan(receiver)\n            closeChan(local)\n            receiverId = getReceiver(c)\n            abort("slow receiver: " + receiverId)\n        }\n        c <- event\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Each receiver has its own goroutine.\nThat is, 10 clients means 10 different ",(0,s.jsx)(n.code,{children:"consumerEventLoop()"})," calls running on separate goroutines."]}),"\n",(0,s.jsxs)(n.p,{children:["To detect slow clients, we simply check the value of ",(0,s.jsx)(n.code,{children:"len(c)"})," whenever we submit the new event.\nIf this equals the capacity of the buffer, we drop the receiver and close the connection."]}),"\n",(0,s.jsxs)(n.p,{children:["It is possible to send events directly to the receiver channel and skip ",(0,s.jsx)(n.code,{children:"c"})," on the publisher side which is local inside consumerEventLoop.\nThis requires a simple state machine and a temporary slice of new events, since we are not allowed to send directly as long as the history is being transmitted.\nOverall, this is more complicated than the one described above."]}),"\n",(0,s.jsx)(n.p,{children:"The simplicity of this method is notable, which is the main advantage: reasoning about its correctness is trivial.\nWe do not need complicated test code and back-and-forth review cycles to ensure that it indeed results in the correct order of events."}),"\n",(0,s.jsx)(n.p,{children:"The biggest question is what happens if channel local becomes full.\nLet's say that localBufferSize is 1000.\nOn a busy cluster with 100 events / second (busiest period), it takes 10 seconds to fill it up completely.\nHowever, nothing stops us from setting the capacity of the buffer to a higher value.\nIf we bump it up to 10000, the client is expected to read the history in 100 seconds.\nOn a decent network, this amount of time should be enough to read the event history, even if it means 100 000 entries from the ring buffer.\nIf a single si.EventRecord results in 300 bytes of JSON text, then it is around 30MiB of data.\nEven if we take serialisation into account, this will not (can not) take minutes."}),"\n",(0,s.jsx)(n.p,{children:"The biggest disadvantage of this method is when a user requests a lot of elements from the history.\nFor example, someone wants to retrieve the last 1M elements.\nIn this case, we need to allocate a slice for 1M entries.\nBased on the measurements, this will generate a sudden spike in the live heap size, around 145-150 MiB. If people repeatedly do this, the memory allocation of YuniKorn can increase very quickly, possibly resulting in a termination of the YuniKorn pod by the kubelet."}),"\n",(0,s.jsx)(n.h4,{id:"stream-new-events-directly-from-ring-buffer",children:(0,s.jsx)(n.strong,{children:"Stream new events directly from ring buffer"})}),"\n",(0,s.jsx)(n.p,{children:"Instead of notifying receivers directly, we just insert the data into the ring buffer.\nFor every client, we create a cursor which points to a given position inside the buffer.\nIf the pointer is behind the tail, it just keeps reading and going forward until it reaches the current tail."}),"\n",(0,s.jsx)(n.p,{children:"Although this method sounds simple on the surface, the implementation is complicated:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When sending the history, we can't rely on ",(0,s.jsx)(n.code,{children:"len(buf)"})," checking.\nIt is because when we are sending the history, we are always very close to the capacity.\nUnlike the previous solution, we are processing elements from the buffer directly, and we do not bridge two channels.\nIf we do that, we just add further complications.\nTherefore, we have to calculate the sending rate, at least while sending past objects.\nIf the pointer is not making progress (or just very slow), then the tail of the ring buffer will catch up to it, but it can take a very long time."]}),"\n",(0,s.jsx)(n.li,{children:"In case of multiple cursors, we have to maintain which one is the closest to the tail.\nIf we don't do that, we have to check every cursor when adding elements.\nWe cannot wait for a slow reader to jump to the next element, so we have to invalidate the cursor, then have to calculate which is the nearest to tail again."}),"\n",(0,s.jsxs)(n.li,{children:["Whenever we reach the last element, we have to block and utilize the well-known wait-notify pattern (",(0,s.jsx)(n.code,{children:"Cond.Broadcast()"})," and ",(0,s.jsx)(n.code,{children:"Cond.Wait()"})," in Go)."]}),"\n",(0,s.jsx)(n.li,{children:"The overall sending logic is much more complicated: keep reading batches from the ring buffer until we reach the last element, then switch to wait-notify and block."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The advantage of this method is that we don't need large channel buffers to make sure that they don't get filled while sending historical records.\nIf the reader is fast enough, we just keep marshalling ",(0,s.jsx)(n.code,{children:"si.EventRecord"})," objects and bump the pointer to the next element."]}),"\n","\n",(0,s.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://pkg.go.dev/strconv#ParseBool",children:"https://pkg.go.dev/strconv#ParseBool"})," ",(0,s.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://pkg.go.dev/strconv#ParseUint",children:"https://pkg.go.dev/strconv#ParseUint"})," ",(0,s.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1780:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>l});var s=t(79474);const i={},r=s.createContext(i);function d(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);