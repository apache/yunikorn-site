"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[10783],{10241:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/application-state-43c26f8a6a803d863e8ef73311f786eb.png"},18765:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"developer_guide/scheduler_object_states","title":"Scheduler Object States","description":"\x3c!--","source":"@site/docs/developer_guide/scheduler_object_states.md","sourceDirName":"developer_guide","slug":"/developer_guide/scheduler_object_states","permalink":"/docs/next/developer_guide/scheduler_object_states","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"scheduler_object_states","title":"Scheduler Object States"},"sidebar":"docs","previous":{"title":"Development in CodeReady Containers","permalink":"/docs/next/developer_guide/openshift_development"},"next":{"title":"End-to-End Testing","permalink":"/docs/next/developer_guide/e2e_test"}}');var i=n(47259),s=n(89796);const o={id:"scheduler_object_states",title:"Scheduler Object States"},c=void 0,r={},l=[{value:"Core Scheduler",id:"core-scheduler",level:2},{value:"Application State",id:"application-state",level:3},{value:"Object State",id:"object-state",level:3},{value:"Node",id:"node",level:3},{value:"K8Shim Resource Manager",id:"k8shim-resource-manager",level:2},{value:"Application",id:"application",level:3},{value:"Task",id:"task",level:3}];function d(e){const t={br:"br",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"The YuniKorn project uses state machines to track the states of different objects.\nThis ranges from applications in the core to nodes in the k8shim.\nThe state machines are independent and not shared between the resource managers and core.\nA resource manager shim, and the core can thus have an independent idea of the state of a similar object."}),"\n",(0,i.jsx)(t.h2,{id:"core-scheduler",children:"Core Scheduler"}),"\n",(0,i.jsx)(t.p,{children:"State change are triggered by events that get processed.\nOne event can cause a change for multiple states or no change at all."}),"\n",(0,i.jsx)(t.h3,{id:"application-state",children:"Application State"}),"\n",(0,i.jsx)(t.p,{children:"Applications have a complex state model.\nAn application when created starts ain the new state."}),"\n",(0,i.jsx)(t.p,{children:"An application can have the following states:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"New: A new application that is being submitted or created, from here the application transitions into the accepted state when it is ready for scheduling.\nThe first ask to be added will trigger the transition."}),"\n",(0,i.jsx)(t.li,{children:"Accepted: The application is ready and part of the scheduling cycle.\nOn allocation of the first ask the application moves into a running state.\nThis state is part of the normal scheduling cycle."}),"\n",(0,i.jsx)(t.li,{children:"Running: The state in which the application will spend most of its time.\nContainers/pods can be added to and removed from the application.\nThis state is part of the normal scheduling cycle."}),"\n",(0,i.jsx)(t.li,{children:"Completing: An application that has no pending requests or running containers/pod will be completing.\nThis state shows that the application has not been marked completed yet but currently is not actively being scheduled."}),"\n",(0,i.jsx)(t.li,{children:"Completed: An application is considered completed when it has been in the completing state for a defined time period.\nFrom this state the application can only move to the Expired state, and it cannot move back into any of scheduling states (Running or Completing)\nThe current timeout is set to 30 seconds."}),"\n",(0,i.jsx)(t.li,{children:"Expired: The completed application is tracked for a period of time, after that is expired and deleted from the scheduler.\nThis is a final state and after this state the application cannot be tracked anymore."}),"\n",(0,i.jsx)(t.li,{children:"Failing: An application marked for failing, what still has some allocations or asks what needs to be cleaned up before entering into the Failed state.\nThe application can be Failing when the partition it belongs to is removed or during gang scheduling, if the placeholder processing times out, and the application has no real allocations yet."}),"\n",(0,i.jsx)(t.li,{children:"Failed: An application is considered failed when it was marked for failure and all the pending requests and allocations were already removed.\nFrom this state the application can only move to the Expired state."}),"\n",(0,i.jsx)(t.li,{children:"Rejected: The application was rejected when it was added to the scheduler.\nThis only happens when a resource manager tries to add a new application, when it gets created in a New state, and the scheduler rejects the creation.\nApplications can be rejected due ACLs denying access to a queue the application has specified, or a placement via placement rules has failed. From this state the application can only move to the Expired state."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The events that can trigger a state change:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Reject: rejecting the application by the scheduler (source: core scheduler)"}),"\n",(0,i.jsx)(t.li,{children:"Run: progress an application to the next active state (source: core scheduler)"}),"\n",(0,i.jsx)(t.li,{children:"Complete: mark an application as idle or complete (source: core scheduler)"}),"\n",(0,i.jsx)(t.li,{children:"Fail: fail an application (source: resource manager or core scheduler)"}),"\n",(0,i.jsx)(t.li,{children:"Expire: progress the application to the expired state and remove it from the scheduler (source: core scheduler)"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Here is a diagram that shows the states with the event that causes the state to change:",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.img,{alt:"application state diagram",src:n(10241).A+"",width:"673",height:"819"})]}),"\n",(0,i.jsx)(t.h3,{id:"object-state",children:"Object State"}),"\n",(0,i.jsx)(t.p,{children:"The object state is used by the following objects:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"queues"}),"\n",(0,i.jsx)(t.li,{children:"partitions"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The object states are as follows:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Active: The object is active and used during the scheduling cycle.\nThis is the starting and normal state of an object.\nAn active object transitions to draining when it is removed."}),"\n",(0,i.jsx)(t.li,{children:"Stopped: The object is stopped and no longer actively scheduled.\nThe object if empty is ready to be removed from the scheduler.\nThe object can transition back into active state if it gets re-started."}),"\n",(0,i.jsx)(t.li,{children:"Draining: Before an object can be removed it needs to be cleaned up.\nThe cleanup starts with placing the object in the draining state.\nIn this state it does not accept additions or changes but is still actively being scheduled.\nThis allows for a graceful shutdown, cleanup and removal of the object.\nThis is the final state."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The events that can trigger a state change:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Start: make the object active (source: core scheduler)"}),"\n",(0,i.jsx)(t.li,{children:"Stop: make the object inactive (source: core scheduler)"}),"\n",(0,i.jsx)(t.li,{children:"Remove: mark an object for removal (source: core scheduler)"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Here is a diagram that shows the states with the event that causes the state to change:",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.img,{alt:"object state diagram",src:n(68406).A+"",width:"620",height:"266"})]}),"\n",(0,i.jsx)(t.h3,{id:"node",children:"Node"}),"\n",(0,i.jsxs)(t.p,{children:["Node objects in the core are not using a state machine but do have a state.\nA node can have one of two states: ",(0,i.jsx)(t.code,{children:"schedulable"})," or ",(0,i.jsx)(t.code,{children:"not schedulable"}),".\nThere is no complex state model or complex transition logic.\nThe scheduler can either use the node or not."]}),"\n",(0,i.jsx)(t.p,{children:"The node status changes based on the status provided by the resource manager (shim) that owns the node."}),"\n",(0,i.jsx)(t.h2,{id:"k8shim-resource-manager",children:"K8Shim Resource Manager"}),"\n",(0,i.jsx)(t.h3,{id:"application",children:"Application"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"application state diagram",src:n(53104).A+"",width:"1648",height:"913"})}),"\n",(0,i.jsx)(t.h3,{id:"task",children:"Task"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"task state diagram",src:n(58971).A+"",width:"1151",height:"888"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},53104:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/k8shim-application-state-8592e75a3f23f02935dff934ab123fcf.png"},58971:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/k8shim-task-state-d4401775b2d19b06411602d36939a263.png"},68406:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/object-state-ce78c19f65c895bbbddd0e48b4c22d8f.png"},89796:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var a=n(96363);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);