"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[18122],{83176:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>t,metadata:()=>a,toc:()=>u});var s=n(13274),i=n(1780);const t={id:"core_features",title:"Features",keywords:["feature"]},o=void 0,a={id:"get_started/core_features",title:"Features",description:"\x3c!--",source:"@site/versioned_docs/version-1.3.0/get_started/core_features.md",sourceDirName:"get_started",slug:"/get_started/core_features",permalink:"/docs/1.3.0/get_started/core_features",draft:!1,unlisted:!1,tags:[],version:"1.3.0",frontMatter:{id:"core_features",title:"Features",keywords:["feature"]},sidebar:"docs",previous:{title:"Get Started",permalink:"/docs/1.3.0/"},next:{title:"Deployment Modes",permalink:"/docs/1.3.0/user_guide/deployment_modes"}},c={},u=[{value:"App-aware scheduling",id:"app-aware-scheduling",level:2},{value:"Hierarchy Resource Queues",id:"hierarchy-resource-queues",level:2},{value:"Gang Scheduling",id:"gang-scheduling",level:2},{value:"Job Ordering and Queuing",id:"job-ordering-and-queuing",level:2},{value:"Resource fairness",id:"resource-fairness",level:2},{value:"Resource Reservation",id:"resource-reservation",level:2},{value:"Throughput",id:"throughput",level:2},{value:"MaxApplication Enforcement",id:"maxapplication-enforcement",level:2},{value:"CPU Architecture support",id:"cpu-architecture-support",level:2}];function d(e){const r={a:"a",code:"code",h2:"h2",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.p,{children:"The main features of YuniKorn include:"}),"\n",(0,s.jsx)(r.h2,{id:"app-aware-scheduling",children:"App-aware scheduling"}),"\n",(0,s.jsx)(r.p,{children:"One of the key differences of YuniKorn is, it does app-aware scheduling. In default K8s scheduler, it simply schedules\npod by pod, without any context about user, app, queue. However, YuniKorn recognizes users, apps, queues, and it considers\na lot more factors, e.g resource, ordering etc, while making scheduling decisions. This gives us the possibility to do\nfine-grained controls on resource quotas, resource fairness and priorities, which are the most important requirements\nfor a multi-tenancy computing system."}),"\n",(0,s.jsx)(r.h2,{id:"hierarchy-resource-queues",children:"Hierarchy Resource Queues"}),"\n",(0,s.jsx)(r.p,{children:"Hierarchy queues provide an efficient mechanism to manage cluster resources. The hierarchy of the queues can logically\nmap to the structure of an organization. This gives fine-grained control over resources for different tenants. The YuniKorn\nUI provides a centralised view to monitor the usage of resource queues, it helps you to get the insight how the resources are\nused across different tenants. What's more, By leveraging the min/max queue capacity, it can define how elastic it can be\nin terms of the resource consumption for each tenant."}),"\n",(0,s.jsx)(r.h2,{id:"gang-scheduling",children:"Gang Scheduling"}),"\n",(0,s.jsx)(r.p,{children:"An application can request a set of resources, i.e. a gang, to be scheduled all at once.\nThe gang defines all the resources the application requires to start.\nDuring the first scheduling phase all resources requested will be reserved.\nThe application will only be started when all requested resources are available."}),"\n",(0,s.jsxs)(r.p,{children:["Reservation duration and application behaviour when the reservation fails are configurable.\nIt is even possible to create multiple gangs of different specifications for one application.\nSee the ",(0,s.jsx)(r.a,{href:"/docs/1.3.0/design/gang_scheduling",children:"gang design"})," and the Gang Scheduling ",(0,s.jsx)(r.a,{href:"/docs/1.3.0/user_guide/gang_scheduling",children:"user guide"})," for more details."]}),"\n",(0,s.jsx)(r.h2,{id:"job-ordering-and-queuing",children:"Job Ordering and Queuing"}),"\n",(0,s.jsxs)(r.p,{children:["Applications can be properly queued in working-queues, the ordering policy determines which application can get resources first.\nThe policy can be various, such as simple ",(0,s.jsx)(r.code,{children:"FIFO"}),", ",(0,s.jsx)(r.code,{children:"Fair"}),", ",(0,s.jsx)(r.code,{children:"StateAware"})," or ",(0,s.jsx)(r.code,{children:"Priority"})," based. Queues can maintain the order of applications,\nand based on different policies, the scheduler allocates resources to jobs accordingly. The behavior is much more predictable."]}),"\n",(0,s.jsx)(r.p,{children:"What's more, when the queue max-capacity is configured, jobs and tasks can be properly queued up in the resource queue.\nIf the remaining capacity is not enough, they can be waiting in line until some resources are released. This simplifies\nthe client side operation. Unlike the default scheduler, resources are capped by namespace resource quotas,\nand that is enforced by the quota-admission-controller, if the underneath namespace has no enough quota, pods cannot be\ncreated. Client side needs complex logic, e.g retry by condition, to handle such scenarios."}),"\n",(0,s.jsx)(r.h2,{id:"resource-fairness",children:"Resource fairness"}),"\n",(0,s.jsx)(r.p,{children:"In a multi-tenant environment, a lot of users are sharing cluster resources. To avoid tenants from competing resources\nand potential get starving. More fine-grained fairness needs to achieve fairness across users, as well as teams/organizations.\nWith consideration of weights or priorities, some more important applications can get high demand resources that stand over its share.\nThis is often associated with resource budget, a more fine-grained fairness mode can further improve the expense control."}),"\n",(0,s.jsx)(r.h2,{id:"resource-reservation",children:"Resource Reservation"}),"\n",(0,s.jsx)(r.p,{children:"YuniKorn automatically does reservations for outstanding requests. If a pod could not be allocated, YuniKorn will try to\nreserve it on a qualified node and tentatively allocate the pod on this reserved node (before trying rest of nodes).\nThis mechanism can avoid this pod gets starved by later submitted smaller, less-picky pods.\nThis feature is important in the batch workloads scenario because when a large amount of heterogeneous pods is submitted\nto the cluster, it's very likely some pods can be starved even they are submitted much earlier."}),"\n",(0,s.jsx)(r.h2,{id:"throughput",children:"Throughput"}),"\n",(0,s.jsxs)(r.p,{children:["Throughput is a key criterion to measure scheduler performance. It is critical for a large scale distributed system.\nIf throughput is bad, applications may waste time on waiting for scheduling, and further impact service SLAs.\nWhen the cluster gets bigger, it also means the requirement of higher throughput. The ",(0,s.jsx)(r.a,{href:"/docs/1.3.0/performance/evaluate_perf_function_with_kubemark",children:"performance evaluation based on Kube-mark"}),"\nreveals some perf numbers."]}),"\n",(0,s.jsx)(r.h2,{id:"maxapplication-enforcement",children:"MaxApplication Enforcement"}),"\n",(0,s.jsxs)(r.p,{children:["MaxApplication enforcement feature allows users to limit the number of running applications for a configured queue.\nThis feature is critical in large scale batch workloads.\nWithout this feature, when there are a large number of concurrent jobs launched, they would compete for resources and a certain a mount of resources will be wasted, which could lead to job failure.\nThe ",(0,s.jsx)(r.a,{href:"/docs/1.3.0/user_guide/queue_config",children:"Partition and Queue Configuration"})," provides configuration examples."]}),"\n",(0,s.jsx)(r.h2,{id:"cpu-architecture-support",children:"CPU Architecture support"}),"\n",(0,s.jsx)(r.p,{children:"YuniKorn supports running on ARM as well as on AMD/Intel CPUs.\nWith the release of YuniKorn 1.1.0 prebuilt convenience images for both architectures are provided in the docker hub."})]})}function l(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1780:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var s=n(79474);const i={},t=s.createContext(i);function o(e){const r=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:r},e.children)}}}]);