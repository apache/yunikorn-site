"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[32861],{71869:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>a});var t=i(13274),s=i(1780);const o={id:"scheduler_plugin",title:"K8s Scheduler Plugin"},l=void 0,r={id:"design/scheduler_plugin",title:"K8s Scheduler Plugin",description:"\x3c!--",source:"@site/versioned_docs/version-1.0.0/design/scheduler_plugin.md",sourceDirName:"design",slug:"/design/scheduler_plugin",permalink:"/docs/1.0.0/design/scheduler_plugin",draft:!1,unlisted:!1,tags:[],version:"1.0.0",frontMatter:{id:"scheduler_plugin",title:"K8s Scheduler Plugin"},sidebar:"docs",previous:{title:"Gang scheduling design",permalink:"/docs/1.0.0/design/gang_scheduling"},next:{title:"Evaluate YuniKorn Performance with Kubemark",permalink:"/docs/1.0.0/performance/evaluate_perf_function_with_kubemark"}},d={},a=[{value:"Background",id:"background",level:2},{value:"Design",id:"design",level:2},{value:"Entrypoints",id:"entrypoints",level:2},{value:"Shim Scheduler Changes",id:"shim-scheduler-changes",level:2},{value:"Plugin Implementation",id:"plugin-implementation",level:2},{value:"PreFilter",id:"prefilter",level:3},{value:"Filter",id:"filter",level:3},{value:"PostBind",id:"postbind",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,t.jsx)(n.p,{children:"YuniKorn (on Kubernetes) is traditionally implemented as a ground-up implementation of a Kubernetes scheduler.\nThis has allowed us to innovate rapidly, but is not without its problems; we currently have numerous places\nwhere we call into non-public K8S source code APIs with varying levels of (code) stability, requiring\nsometimes very disruptive code changes when we switch to new Kubernetes releases."}),"\n",(0,t.jsx)(n.p,{children:"Ideally, we should be able to take advantage of enhancements to new Kubernetes releases automatically.\nUsing the plugin model enables us to enhance the Kubernetes scheduling logic with YuniKorn features.\nThis also helps keep YuniKorn compatible with new Kubernetes releases with minimal effort."}),"\n",(0,t.jsx)(n.p,{children:"Additionally, it is desirable in many cases to allow non-batch workloads to bypass the YuniKorn scheduling\nfunctionality and use default scheduling logic. However, we have no way to do that today as the default\nscheduling functionality is not present in the YuniKorn scheduler binary."}),"\n",(0,t.jsxs)(n.p,{children:["Since Kubernetes 1.19, the Kubernetes project has created a stable API for the\n",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/",children:"Scheduling Framework"}),",\nwhich allows plugins to be created which implement various extension points. Plugins implement one or more\nof these extension points, and are then compiled into a scheduler binary which contains the default\nscheduler and plugin code, configured to call into the plugins during normal scheduling flow."]}),"\n",(0,t.jsx)(n.h2,{id:"design",children:"Design"}),"\n",(0,t.jsx)(n.p,{children:"We have added a scheduler plugin to the k8s-shim codebase which can be used to build a Kubernetes\nscheduler binary that includes YuniKorn functionality as well as the default scheduler functionality,\nsignificantly improving the compatibility of YuniKorn with upstream Kubernetes and allowing deployment of\nYuniKorn as the sole scheduler in a cluster with much greater confidence."}),"\n",(0,t.jsxs)(n.p,{children:["Separate docker images are created for the scheduler. The traditional YuniKorn scheduler is built as\n",(0,t.jsx)(n.code,{children:"scheduler-{version}"})," while the new plugin version is built as ",(0,t.jsx)(n.code,{children:"scheduler-plugin-{version}"}),". Either can be\ndeployed interchangeably into a Kubernetes cluster with the same helm charts by customizing the scheduler\nimage to deploy."]}),"\n",(0,t.jsx)(n.h2,{id:"entrypoints",children:"Entrypoints"}),"\n",(0,t.jsxs)(n.p,{children:["The existing shim ",(0,t.jsx)(n.code,{children:"main()"})," method has been relocated to ",(0,t.jsx)(n.code,{children:"pkg/cmd/shim/main.go"}),", and a new ",(0,t.jsx)(n.code,{children:"main()"})," method\nunder ",(0,t.jsx)(n.code,{children:"pkg/cmd/schedulerplugin/main.go"})," has be created. This method instantiates the default Kubernetes\nscheduler and adds YuniKorn to it as a set of plugins. It also modifies the default scheduler CLI argument\nparsing to add YuniKorn-specific options. When the YuniKorn plugin is created, it will launch an instance\nof the existing shim / core schedulers in the background, sync all informers, and start the normal YuniKorn\nscheduling loop."]}),"\n",(0,t.jsx)(n.h2,{id:"shim-scheduler-changes",children:"Shim Scheduler Changes"}),"\n",(0,t.jsx)(n.p,{children:"In order to cooperate with the default scheduler, the shim needs to operate slightly differently when in\nplugin mode. These differences include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In ",(0,t.jsx)(n.code,{children:"postTaskAllocated()"}),", we don\u2019t actually bind the Pod or Volumes, as this is the responsibility of\nthe default scheduler framework. Instead, we track the Node that YK allocated for the Node in an\ninternal map, dispatch a new BindTaskEvent, and record a ",(0,t.jsx)(n.code,{children:"QuotaApproved"})," event on the Pod."]}),"\n",(0,t.jsxs)(n.li,{children:["In ",(0,t.jsx)(n.code,{children:"postTaskBound()"}),", we update the Pod\u2019s state to ",(0,t.jsx)(n.code,{children:"QuotaApproved"})," as this will cause the default scheduler\nto re-evaluate the pod for scheduling (more on this below)."]}),"\n",(0,t.jsx)(n.li,{children:"In the scheduler cache, we track pending and in-progress pod allocations, and remove them if a pod is\nremoved from the cache."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"plugin-implementation",children:"Plugin Implementation"}),"\n",(0,t.jsx)(n.p,{children:"To expose the entirety of YuniKorn functionality, we implement three of the Scheduling Framework Plugins:"}),"\n",(0,t.jsx)(n.h3,{id:"prefilter",children:"PreFilter"}),"\n",(0,t.jsxs)(n.p,{children:["PreFilter plugins are passed a reference to a Pod and return either ",(0,t.jsx)(n.code,{children:"Success"})," or ",(0,t.jsx)(n.code,{children:"Unschedulable"}),", depending\non whether that pod should be considered for scheduling."]}),"\n",(0,t.jsxs)(n.p,{children:["For the YuniKorn implementation, we first check the Pod to see if we have an associated ",(0,t.jsx)(n.code,{children:"applicationId"}),"\ndefined. If not, we immediately return ",(0,t.jsx)(n.code,{children:"Success"}),", which allows us to delegate to the default scheduler for\nnon-batch workloads."]}),"\n",(0,t.jsxs)(n.p,{children:["If an ",(0,t.jsx)(n.code,{children:"applicationId"})," is present, then we determine if there is a pending pod allocation (meaning the\nYuniKorn core has already decided to allocate the pod). If so, we return ",(0,t.jsx)(n.code,{children:"Success"}),", otherwise ",(0,t.jsx)(n.code,{children:"Unschedulable"}),".\nAdditionally, if an in-progress allocation is detected (indicating that we have previously attempted to\nschedule this pod), we trigger a ",(0,t.jsx)(n.code,{children:"RejectTask"})," event for the YuniKorn core so that the pod will be sent back\nfor scheduling later."]}),"\n",(0,t.jsx)(n.h3,{id:"filter",children:"Filter"}),"\n",(0,t.jsx)(n.p,{children:"Filter plugins are used to filter out nodes that cannot run a Pod. Only Pods which pass the PreFilter stage\nare evaluated."}),"\n",(0,t.jsx)(n.p,{children:"For the YuniKorn plugin, we follow similar logic to PreFilter, except that we also validate that the pending\npod allocation matches the node YuniKorn chose for the pod. If the node matches, we transition the pending\nallocation to an in-progress allocation. This helps ensure that we stay in sync with the default scheduler,\nas it is possible that we allow an allocation to proceed but the bind fails for some reason."}),"\n",(0,t.jsx)(n.h3,{id:"postbind",children:"PostBind"}),"\n",(0,t.jsx)(n.p,{children:"The PostBind extension point is used informationally to notify the plugin that a pod was successfully bound."}),"\n",(0,t.jsx)(n.p,{children:"The YuniKorn implementation uses this to clean up the outstanding in-progress pod allocations."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1780:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(79474);const s={},o=t.createContext(s);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);