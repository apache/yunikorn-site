"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[16081],{15680:(e,a,t)=>{t.d(a,{xA:()=>p,yg:()=>g});var n=t(96540);function o(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){o(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,o=function(e,a){if(null==e)return{};var t,n,o={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(o[t]=e[t]);return o}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var r=n.createContext({}),h=function(e){var a=n.useContext(r),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},p=function(e){var a=h(e.components);return n.createElement(r.Provider,{value:a},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,o=e.mdxType,l=e.originalType,r=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=h(t),u=o,g=c["".concat(r,".").concat(u)]||c[u]||d[u]||l;return t?n.createElement(g,i(i({ref:a},p),{},{components:t})):n.createElement(g,i({ref:a},p))}));function g(e,a){var t=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var l=t.length,i=new Array(l);i[0]=u;var s={};for(var r in a)hasOwnProperty.call(a,r)&&(s[r]=a[r]);s.originalType=e,s[c]="string"==typeof e?e:o,i[1]=s;for(var h=2;h<l;h++)i[h]=t[h];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},32205:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>r,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>h});var n=t(58168),o=(t(96540),t(15680));const l={id:"gang_scheduling",title:"Gang scheduling design"},i=void 0,s={unversionedId:"design/gang_scheduling",id:"version-0.11.0/design/gang_scheduling",title:"Gang scheduling design",description:"\x3c!--",source:"@site/versioned_docs/version-0.11.0/design/gang_scheduling.md",sourceDirName:"design",slug:"/design/gang_scheduling",permalink:"/docs/0.11.0/design/gang_scheduling",draft:!1,tags:[],version:"0.11.0",frontMatter:{id:"gang_scheduling",title:"Gang scheduling design"},sidebar:"version-0.11.0/docs",previous:{title:"Scheduler Object States",permalink:"/docs/0.11.0/design/scheduler_object_states"},next:{title:"Evaluate YuniKorn function & performance with Kubemark",permalink:"/docs/0.11.0/performance/evaluate_perf_function_with_kubemark"}},r={},h=[{value:"Document goals",id:"document-goals",level:2},{value:"Excluded design points",id:"excluded-design-points",level:2},{value:"Generic flow",id:"generic-flow",level:2},{value:"Application submit handling",id:"application-submit-handling",level:2},{value:"Total placeholder size",id:"total-placeholder-size",level:3},{value:"Handling queue with a FAIR sort policy",id:"handling-queue-with-a-fair-sort-policy",level:3},{value:"Scheduling in queues with a quota set",id:"scheduling-in-queues-with-a-quota-set",level:2},{value:"Scheduler logic changes",id:"scheduler-logic-changes",level:2},{value:"Application completion",id:"application-completion",level:2},{value:"Definition",id:"definition",level:3},{value:"Cleanup",id:"cleanup",level:3},{value:"Application recovery",id:"application-recovery",level:2},{value:"Interface changes",id:"interface-changes",level:2},{value:"AddApplication",id:"addapplication",level:3},{value:"AllocationAsk",id:"allocationask",level:3},{value:"Allocation",id:"allocation",level:3},{value:"AllocationRelease Response and Request",id:"allocationrelease-response-and-request",level:3},{value:"TerminationType",id:"terminationtype",level:3},{value:"AllocationAskRelease Response and Request",id:"allocationaskrelease-response-and-request",level:3},{value:"Scheduler storage object changes",id:"scheduler-storage-object-changes",level:2},{value:"AllocationAsk",id:"allocationask-1",level:3},{value:"Allocation",id:"allocation-1",level:3},{value:"Application",id:"application",level:3},{value:"Queue &amp; Node",id:"queue--node",level:3}],p={toc:h},c="wrapper";function d(e){let{components:a,...l}=e;return(0,o.yg)(c,(0,n.A)({},p,l,{components:a,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"gang-scheduling-implementation"},"Gang Scheduling Implementation"),(0,o.yg)("p",null,"A new way of scheduling applications by taking into account the demand for resources the application expects it will generate over time.\nIt guarantees the expected demand resources for the application by reserving the resources."),(0,o.yg)("p",null,"There are two parts to this implementation:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Kubernetes Shim"),(0,o.yg)("li",{parentName:"ul"},"Core and scheduling")),(0,o.yg)("p",null,"This document describes the implementation on the core side."),(0,o.yg)("h2",{id:"document-goals"},"Document goals"),(0,o.yg)("p",null,"This document describes the following implementation design points:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Define changes required for the shim to core communication (scheduler interface)"),(0,o.yg)("li",{parentName:"ol"},"Scheduler storage object changes"),(0,o.yg)("li",{parentName:"ol"},"Scheduler logic changes")),(0,o.yg)("h2",{id:"excluded-design-points"},"Excluded design points"),(0,o.yg)("p",null,"Currently, the Kubernetes shim side implementation is not covered in this design document."),(0,o.yg)("p",null,"Generalised preemption on the core side will ",(0,o.yg)("em",{parentName:"p"},"not")," be discussed in this design."),(0,o.yg)("h2",{id:"generic-flow"},"Generic flow"),(0,o.yg)("p",null,"The flow is triggered by a pod that is submitted which triggers the application creation.\nThis first pod is in the case of a Spark application, the driver pod.\nIn case the flow is triggered from the creation of an application CRD there will not be a first pod.\nThis is however outside the core scheduling logic. From the core side there should be no difference between the two cases.\nMore details are in the chapter on the ",(0,o.yg)("a",{parentName:"p",href:"#scheduler-logic-changes"},"Scheduler logic changes"),"."),(0,o.yg)("p",null,"The flow of an application submitted. The numbers in the diagram correspond to the description below the diagram."),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"generic flow",src:t(88905).A,width:"1219",height:"820"})),(0,o.yg)("p",null,"Combined flow for the shim and core during startup of an application:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"An application is submitted with TaskGroup(s) defined. (1)"),(0,o.yg)("li",{parentName:"ul"},"The shim creates the application and passes the application to the core. (2)"),(0,o.yg)("li",{parentName:"ul"},"The shim creates placeholder pods for each of the members of the TaskGroup(s) (3)"),(0,o.yg)("li",{parentName:"ul"},"The pods are processed and passed to the core, as per the normal behaviour, as AllocationAsks for the application with the correct info set. (4)"),(0,o.yg)("li",{parentName:"ul"},"The placeholder AllocationAsk\u2019s are scheduled by the core as if they were normal AllocationAsk\u2019s. (5)"),(0,o.yg)("li",{parentName:"ul"},"All Allocations, even if they are the result of the placeholder AllocationAsks being allocated by the scheduler, are communicated back to the shim."),(0,o.yg)("li",{parentName:"ul"},"The original real pod is passed to the core as an AllocationAsk. (6)"),(0,o.yg)("li",{parentName:"ul"},"After the real pod and all all the placeholder pods are scheduled the shim starts the real pod that triggered the application creation. (7)")),(0,o.yg)("p",null,"After the first, real, pod is started the following pods should all be handled in the same way (8):"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"A real pod is created on k8s."),(0,o.yg)("li",{parentName:"ul"},"The pod is processed and an AllocationAsk is created."),(0,o.yg)("li",{parentName:"ul"},"The scheduler processes the AllocationAsk (more detail below) and replaces a placeholder with the real allocation.")),(0,o.yg)("h2",{id:"application-submit-handling"},"Application submit handling"),(0,o.yg)("h3",{id:"total-placeholder-size"},"Total placeholder size"),(0,o.yg)("p",null,"The application if requesting one or more TaskGroups should provide the total size of all the TaskGroup members it is going to request.\nThe total resource size is required for the case that the application is scheduled in a queue with a resource limit set."),(0,o.yg)("p",null,"The value is important for three cases:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"gang request is larger than the queue quota"),(0,o.yg)("li",{parentName:"ol"},"start of scheduling reservations"),(0,o.yg)("li",{parentName:"ol"},"resource pressure while scheduling reservations")),(0,o.yg)("p",null,"Further detail will be given below in ",(0,o.yg)("a",{parentName:"p",href:"#scheduling-in-queues-with-a-quota-set"},"scheduling in queues with a quota set")),(0,o.yg)("p",null,"The information passed on from the shim should be part of the AddApplicationRequest.\nDetailed information on the build up of the taskGroup(s), or the number of members are not relevant.\nThe total resource requested by all taskGroup members is calculated using:"),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"ask caclulation",src:t(91215).A,width:"663",height:"117"})),(0,o.yg)("p",null,"This total placeholderAsk is added as an optional field to the AddApplicationRequest message.\nThe calculation can be made by the shim based on the CRD or annotation provided in the pod description."),(0,o.yg)("p",null,"If the placeholderAsk is larger than the queue quota set on the queue the application must be rejected.\nThis rejection is based on the fact that we cannot in any way honor the request.\nFor all other cases the application is accepted and will be scheduled as per normal."),(0,o.yg)("h3",{id:"handling-queue-with-a-fair-sort-policy"},"Handling queue with a FAIR sort policy"),(0,o.yg)("p",null,"If an application is submitted to a queue that has a FAIR sort policy set it must be rejected.\nQueue sorting for the queue that the application runs in must be set to ",(0,o.yg)("em",{parentName:"p"},"FIFO")," or ",(0,o.yg)("em",{parentName:"p"},"StateAware"),"."),(0,o.yg)("p",null,"Other queue policies cannot guarantee that there is only one ",(0,o.yg)("em",{parentName:"p"},"New")," application processed at a time.\nIn the case of the ",(0,o.yg)("em",{parentName:"p"},"FAIR")," policy we could be allocating multiple ",(0,o.yg)("em",{parentName:"p"},"New")," applications at the same time making quota management impossible to enforce.\nThe other side effect of using ",(0,o.yg)("em",{parentName:"p"},"FAIR")," as a policy could be that we get multiple applications with only a partial allocated guarantee."),(0,o.yg)("p",null,"Auto-scaling can be triggered due to the fact that the core can not place the placeholders on any node.\nIn case the queue would use the ",(0,o.yg)("em",{parentName:"p"},"FAIR")," sorting this could lead to other applications taking the scaled up nodes instead of the placeholders again breaking the gang."),(0,o.yg)("h2",{id:"scheduling-in-queues-with-a-quota-set"},"Scheduling in queues with a quota set"),(0,o.yg)("p",null,"The main case already described above is handling a total placeholder request size that is larger than the quota set on the queue.\nWhen the application is submitted we can already assess that we cannot satisfy that requirement and reject the request."),(0,o.yg)("p",null,"In the case that the total placeholder ask does fit in the queue we should not start scheduling until there are enough resources available in the queue to satisfy the total request.\nHowever this does not stop scheduling of other applications in the queue(s).\nApplications that are already running in the queue could ask for more resources.\nFrom an application perspective there is no limit set on the resource it can request.\nThe gang defined on the application is a guaranteed number of resources, not a maximum number of resources the application can request."),(0,o.yg)("p",null,"This is complicated by the fact that we have a queue hierarchy.\nThere is the possibility that the quota is not set directly on the queue the application is running.\nIt could be set on one of the parent queues.\nThis case could become complex, and we need to make sure that we keep in mind that we could live lock the scheduling."),(0,o.yg)("p",null,"In this first phase we should focus on the case that the gang resources requested are also the maximum number of resources the application will request.\nWhen we look at the queues we should focus on a single queue level with quotas."),(0,o.yg)("p",null,"These two assumptions are correct for the spark use case without dynamic allocation using a dynamic mapping from a namespace to a queue."),(0,o.yg)("p",null,"Furthermore, we assume that the quota set on the queue can be totally allocated.\nIf the cluster does not have enough resources the cluster will scale up to the size needed to provide all queues with their full quota."),(0,o.yg)("p",null,"The follow up should add further enhancements for deeper hierarchies and dynamic allocation support.\nThis could also leverage preemption in certain use cases, like preempting allocations from applications over their total gang size."),(0,o.yg)("p",null,"Further enhancements could be added by allowing specifying the time and application will wait for the placeholders to be allocated, or the time to start using the held resources."),(0,o.yg)("h2",{id:"scheduler-logic-changes"},"Scheduler logic changes"),(0,o.yg)("p",null,"The scheduler logic change needs to account for two parts of cycle:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"The placeholder asks and their allocation."),(0,o.yg)("li",{parentName:"ul"},"The allocation replacing the placeholder.")),(0,o.yg)("p",null,"The basic assumption is that all pods will generate a placeholder pod request to the core.\nThis includes the pod that triggered the application creation if we do not use the application CRD.\nThis assumption is needed to make sure that the scheduler core can behave in the same way for both ways of submitting the application.\nThe placeholder pods must be communicated to the core before the real pod."),(0,o.yg)("p",null,"Changes for the placeholder AllocationAsks are the first step.\nAs part of the creation of the application the AllocationAsks get added.\nThe addition of an AllocationsAsk normally will trigger the application state change as per the scheduling cycle.\nIt moves the Application from a ",(0,o.yg)("em",{parentName:"p"},"New")," state to an ",(0,o.yg)("em",{parentName:"p"},"Accepted")," state. This is as per the current setup, and does not change."),(0,o.yg)("p",null,"However, in the case that the AllocationAsk has the ",(0,o.yg)("em",{parentName:"p"},"placeholder")," flag set the allocation should not trigger a state change, the application stays in ",(0,o.yg)("em",{parentName:"p"},"Accepted")," state.\nAllocationAsks are processed until the application has no pending resources.\nAllocationAsks that do not have a ",(0,o.yg)("em",{parentName:"p"},"placeholder")," flag set should be ignored as a safety precaution.\nAll resulting Allocations for the placeholder pods are confirmed to the shim as per the normal steps.\nThis process continues until there are no more placeholder pods to be allocated."),(0,o.yg)("p",null,"The shim at that point should create the AllocationAsk for the real pod(s) that it has buffered.\nThe core cannot and must not assume that there is only one task group per application.\nThe core is also not in the position to assume that it has received all AllocationAsks that belong to the task group if option 1 as described above is used by a shim.\nThis is also why we have the assumption that every pod creates a placeholder request to the core."),(0,o.yg)("p",null,"The second change is the replacement of the placeholder pods with the real pods.\nThe shim creates an AllocationAsk with the ",(0,o.yg)("em",{parentName:"p"},"taskGroupName")," set but the ",(0,o.yg)("em",{parentName:"p"},"placeholder")," flag is not set."),(0,o.yg)("p",null,"The process described here lines up with the process for generic pre-emption.\nAn allocation is released by the core and then confirmed by the shim.\nFor gang scheduling we have a simple one new to one release relation in the case of pre-emption we can use the same flow with a one new to multiple release relation."),(0,o.yg)("p",null,"The scheduler processes the AllocationAsk as follows:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Check if the application has an unreleased allocation for a placeholder allocation with the same ",(0,o.yg)("em",{parentName:"li"},"taskGroupName.")," If no placeholder allocations are found a normal allocation cycle will be used to allocate the request."),(0,o.yg)("li",{parentName:"ol"},"A placeholder allocation is selected and marked for release. A request to release the placeholder allocation is communicated to the shim. This must be an async process as the shim release process is dependent on the underlying K8s response which might not be instantaneous.",(0,o.yg)("br",{parentName:"li"}),"NOTE: no allocations are released in the core at this point in time."),(0,o.yg)("li",{parentName:"ol"},"The core \u201cparks\u201d the processing of the real AllocationAsk until the shim has responded with a confirmation that the placeholder allocation has been released.",(0,o.yg)("br",{parentName:"li"}),"NOTE: locks are released to allow scheduling to continue"),(0,o.yg)("li",{parentName:"ol"},"After the confirmation of the release is received from the shim the \u201cparked\u201d AllocationAsk processing is finalised."),(0,o.yg)("li",{parentName:"ol"},"The AllocationAsk is allocated on the same node as the placeholder used.\nThe removal of the placeholder allocation is finalised in either case. This all needs to happen as one update to the application, queue and node.",(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},"On success: a new Allocation is created."),(0,o.yg)("li",{parentName:"ul"},"On Failure: try to allocate on a different node, if that fails the AllocationAsk becomes unschedulable triggering scale up. "))),(0,o.yg)("li",{parentName:"ol"},"Communicate the allocation back to the shim (if applicable, based on step 5)")),(0,o.yg)("h2",{id:"application-completion"},"Application completion"),(0,o.yg)("p",null,"Application completion has been a long standing issue.\nCurrently, applications do not transition to a ",(0,o.yg)("em",{parentName:"p"},"completed")," state when done.\nThe current states for the application are ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.11.0/design/scheduler_object_states"},"documented here"),".\nHowever, at this point in time an application will not reach the ",(0,o.yg)("em",{parentName:"p"},"completed")," state and will be stuck in ",(0,o.yg)("em",{parentName:"p"},"waiting"),"."),(0,o.yg)("p",null,"This provides a number of issues specifically around memory usage and cleanup of queues in long running deployments."),(0,o.yg)("h3",{id:"definition"},"Definition"),(0,o.yg)("p",null,"Since we cannot rely on the application, running as pods on Kubernetes, to show that it has finished we need to define when we consider an application ",(0,o.yg)("em",{parentName:"p"},"completed"),".\nAt this point we are defining that an application is ",(0,o.yg)("em",{parentName:"p"},"completed")," when it has been in the ",(0,o.yg)("em",{parentName:"p"},"waiting")," state for a defined time period.\nAn application enters the waiting state at the time that there are no active allocations (allocated resources > 0) and pending allocation asks (pending resources > 0)."),(0,o.yg)("p",null,"The transition to a ",(0,o.yg)("em",{parentName:"p"},"waiting")," state is already implemented.\nThe time out of the ",(0,o.yg)("em",{parentName:"p"},"waiting")," state is new functionality."),(0,o.yg)("p",null,"Placeholders are not considered active allocations.\nPlaceholder asks are considered pending resource asks.\nThese cases will be handled in the ",(0,o.yg)("a",{parentName:"p",href:"#Cleanup"},"Cleanup")," below."),(0,o.yg)("h3",{id:"cleanup"},"Cleanup"),(0,o.yg)("p",null,"When we look at gang scheduling there is a further issue around unused placeholders, placeholder asks and their cleanup.\nPlaceholders could be converted into real allocations at any time there are pending allocation asks or active allocations."),(0,o.yg)("p",null,"Placeholder asks will all be converted into placeholder allocations before the real allocations are processed."),(0,o.yg)("p",null,"Entry into the ",(0,o.yg)("em",{parentName:"p"},"waiting")," state is already handled.\nIf new allocation asks are added to the application it will transition back to a ",(0,o.yg)("em",{parentName:"p"},"running")," state.\nAt the time we entered the waiting state. there were no pending requests or allocated resources.\nThere could be allocated placeholders."),(0,o.yg)("p",null,"For the entry into the ",(0,o.yg)("em",{parentName:"p"},"waiting")," state the application must be clean.\nHowever, we can not guarantee that all placeholders will be used by the application during the time the application runs.\nTransitioning out of the ",(0,o.yg)("em",{parentName:"p"},"waiting")," state into the ",(0,o.yg)("em",{parentName:"p"},"completed")," state requires no (placeholder) allocations or asks at all.\nThe second case that impact transitions is that not all placeholder asks are allocated, and the application thus never requests any real allocations.\nThese two cases could prevent an application from transitioning out of the ",(0,o.yg)("em",{parentName:"p"},"accepted"),", or the ",(0,o.yg)("em",{parentName:"p"},"waiting")," state."),(0,o.yg)("p",null,"Processing in the core thus needs to consider two cases that will impact the transition out of specific states:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Placeholder asks pending (exit from ",(0,o.yg)("em",{parentName:"li"},"accepted"),")"),(0,o.yg)("li",{parentName:"ol"},"Placeholders allocated (exit from ",(0,o.yg)("em",{parentName:"li"},"waiting"),")")),(0,o.yg)("p",null,"Placeholder asks pending:",(0,o.yg)("br",{parentName:"p"}),"\n","Pending placeholder asks are handled via a timeout.\nAn application must only spend a limited time waiting for all placeholders to be allocated.\nThis timeout is needed because an application\u2019s partial placeholders allocation may occupy cluster resources without really using them."),(0,o.yg)("p",null,"An application could be queued for an unknown time, waiting for placeholder allocation to start.\nThe timeout for placeholder asks can thus not be linked to the creation of the application or the asks.\nThe timeout must start at the time the first placeholder ask is allocated."),(0,o.yg)("p",null,"The application cannot request real allocations until all placeholder asks are allocated.\nA placeholder ask is also tracked by the shim as it represents a pod.\nReleasing an ask in the core requires a message to flow between the core and shim to release that ask.\nHowever, in this case the timeout for allocating placeholder asks triggers an application failure.\nWhen the timeout is triggered and placeholder asks are pending the application will transition from the state it is in, which can only be ",(0,o.yg)("em",{parentName:"p"},"accepted"),", to ",(0,o.yg)("em",{parentName:"p"},"killed"),"."),(0,o.yg)("p",null,"The application state for this case can be summarised as:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Application status is ",(0,o.yg)("em",{parentName:"li"},"accepted")),(0,o.yg)("li",{parentName:"ul"},"Placeholder allocated resource is larger than zero, and less than the ",(0,o.yg)("em",{parentName:"li"},"placeholderAsk")," from the ",(0,o.yg)("em",{parentName:"li"},"AddApplicationRequest")),(0,o.yg)("li",{parentName:"ul"},"Pending resource asks is larger than zero")),(0,o.yg)("p",null,"Entering into the ",(0,o.yg)("em",{parentName:"p"},"killed")," state must move the application out of the queue automatically."),(0,o.yg)("p",null,"The state change and placeholder allocation releases can be handled in a single UpdateResponse message. The message will have the following content:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("em",{parentName:"li"},"UpdatedApplication")," for the state change of the application"),(0,o.yg)("li",{parentName:"ul"},"one or more ",(0,o.yg)("em",{parentName:"li"},"AllocationRelease")," messages, one for each placeholder, with the  ",(0,o.yg)("em",{parentName:"li"},"TerminationType")," set to TIMEOUT"),(0,o.yg)("li",{parentName:"ul"},"one or more AllocationAskRelease messages with the ",(0,o.yg)("em",{parentName:"li"},"TerminationType")," set to TIMEOUT")),(0,o.yg)("p",null,"The shim processes the AllocationAskRelease messages first, followed by the ",(0,o.yg)("em",{parentName:"p"},"AllocationResponse")," messages, and finally the ",(0,o.yg)("em",{parentName:"p"},"UpdatedApplication")," message. The application state change to the ",(0,o.yg)("em",{parentName:"p"},"killed")," state on the core side is only dependent on the removal of all placeholders pods, not on a response to the _UpdatedApplication _message."),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"placeholder timeout",src:t(84294).A,width:"1574",height:"635"})),(0,o.yg)("p",null,"Combined flow for the shim and core during timeout of placeholder:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"The core times out the placeholder allocation. (1)"),(0,o.yg)("li",{parentName:"ul"},"The placeholder Allocations removal is passed to the shim. (2)"),(0,o.yg)("li",{parentName:"ul"},"All placeholder Allocations are released by the shim, and communicated back to the core."),(0,o.yg)("li",{parentName:"ul"},"The placeholder AllocationAsks removal is passed to the shim. (3)"),(0,o.yg)("li",{parentName:"ul"},"All placeholder AllocationAsks are released by the shim, and communicated back to the core."),(0,o.yg)("li",{parentName:"ul"},"After the placeholder Allocations and Asks are released the core moves the application to the killed state removing it from the queue (4)."),(0,o.yg)("li",{parentName:"ul"},"The state change is finalised in the core and shim. (5)")),(0,o.yg)("p",null,"Allocated placeholders:",(0,o.yg)("br",{parentName:"p"}),"\n","Leftover placeholders need to be released by the core.\nThe shim needs to be informed to remove them. This must be triggered on entry of the ",(0,o.yg)("em",{parentName:"p"},"completed")," state.\nAfter the placeholder release is requested by the core the state transition of the application can proceed.\nThe core will process the ",(0,o.yg)("em",{parentName:"p"},"AllocationRelease")," messages for placeholder allocations that come back from the shim with the ",(0,o.yg)("em",{parentName:"p"},"TerminationType")," set to TIMEOUT as normal without triggering a state change."),(0,o.yg)("p",null,"The state change and placeholder allocation releases can be handled in a single UpdateResponse message.\nThe message will have the following content:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("em",{parentName:"li"},"UpdatedApplication")," for the state change of the application"),(0,o.yg)("li",{parentName:"ul"},"zero or more ",(0,o.yg)("em",{parentName:"li"},"AllocationRelease")," messages, one for each placeholder, with the  ",(0,o.yg)("em",{parentName:"li"},"TerminationType")," set to TIMEOUT")),(0,o.yg)("p",null,"The shim processes the ",(0,o.yg)("em",{parentName:"p"},"AllocationResponse")," messages first followed by the ",(0,o.yg)("em",{parentName:"p"},"UpdatedApplication")," message.\nThe application state change to the ",(0,o.yg)("em",{parentName:"p"},"completed")," state on the core side is only dependent on the removal of all placeholders pods, not on a response to the _UpdatedApplication _message."),(0,o.yg)("p",null,"Entering into the ",(0,o.yg)("em",{parentName:"p"},"completed")," state will move the application out of the queue automatically.\nThis should also handle the case we discussed earlier around a possible delayed processing of requests from the shim as we can move back from ",(0,o.yg)("em",{parentName:"p"},"waiting")," to ",(0,o.yg)("em",{parentName:"p"},"running")," if needed.\nA ",(0,o.yg)("em",{parentName:"p"},"completed")," application should also not prevent the case that was discussed around cron like submissions using the same application ID for each invocation.\nA ",(0,o.yg)("em",{parentName:"p"},"completed")," application with the same application ID must not prevent the submission of a new application with the same ID."),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"application cleanup flow",src:t(18066).A,width:"1574",height:"635"})),(0,o.yg)("p",null,"Combined flow for the shim and core during cleanup of an application:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"A pod is released at the Kubernetes layer. (1)"),(0,o.yg)("li",{parentName:"ul"},"The shim passes the release of the allocation on to the core. (2)"),(0,o.yg)("li",{parentName:"ul"},"The core transitions the application to a waiting state if no pending or active allocations. (3)"),(0,o.yg)("li",{parentName:"ul"},"The waiting state times out and triggers the cleanup. (4)"),(0,o.yg)("li",{parentName:"ul"},"The placeholder Allocations removal is passed to the shim. (5)"),(0,o.yg)("li",{parentName:"ul"},"All placeholder Allocations are released by the shim, and communicated back to the core."),(0,o.yg)("li",{parentName:"ul"},"After all placeholders are released the core moves the application to the completed state removing it from the queue (6)."),(0,o.yg)("li",{parentName:"ul"},"The state change is finalised in the core and shim. (7)")),(0,o.yg)("h2",{id:"application-recovery"},"Application recovery"),(0,o.yg)("p",null,"During application recovery the placeholder pods are recovered as any other pod on a node.\nThese pods are communicated to the core by the shim as part of the node as an existing allocation.\nExisting allocations do not have a corresponding ",(0,o.yg)("em",{parentName:"p"},"AllocationAsk")," in the core. The core generates an ",(0,o.yg)("em",{parentName:"p"},"AllocationAsk")," based on the recovered information."),(0,o.yg)("p",null,"For gang scheduling the ",(0,o.yg)("em",{parentName:"p"},"AllocationAsk")," contains the ",(0,o.yg)("em",{parentName:"p"},"taskGroupName")," and ",(0,o.yg)("em",{parentName:"p"},"placeholder")," flag.\nDuring recovery that same information must be part of the ",(0,o.yg)("em",{parentName:"p"},"Allocation")," message.\nThis is due to the fact that the same message is used in two directions, from the RM to the scheduler and vice versa means we need to update the message and its processing."),(0,o.yg)("p",null,"If the information is missing from the ",(0,o.yg)("em",{parentName:"p"},"Allocation")," message the recovered allocation will not be correctly tagged in the core.\nThe recovered allocation will be seen as a regular allocation.\nThis means it is skipped as part of the normal allocation cycle that replaces the placeholders."),(0,o.yg)("p",null,"The logic change only requires that the recovery of existing allocations copies the fields from the interface message into the allocation object in the core."),(0,o.yg)("h2",{id:"interface-changes"},"Interface changes"),(0,o.yg)("p",null,"Multiple changes are needed to the communication between the shim and the core to support the gang information needed."),(0,o.yg)("p",null,"An application must provide the total size of the placeholder requests to prevent accepting an application that can never run."),(0,o.yg)("p",null,"The current object that is sent from the shim to the core for allocation requests is defined in the AllocationAsk.\nThe Allocation, as the result message passed back from the scheduler core does not change. For recovery, which uses the same Allocation message, from the shim to the core, however must contain the gang related fields.\nGang related fields must be added to both messages."),(0,o.yg)("p",null,"The allocation release request and response request need to support bidirectional traffic and will need to undergo major changes."),(0,o.yg)("h3",{id:"addapplication"},"AddApplication"),(0,o.yg)("p",null,"The AddApplicationRequest message requires a new field to communicate the total placeholder resource request that will be requested.\nThe field is used to reject the application if it is impossible to satisfy the request.\nIt can also be used to stop the core from scheduling any real pods for that application until all placeholder pods are processed."),(0,o.yg)("p",null,"In patched message form that would look like:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"message AddApplicationRequest {\n...\n  // The total amount of resources gang placeholders will request\n  Resource placeholderAsk = 7;\n...\n}\n")),(0,o.yg)("h3",{id:"allocationask"},"AllocationAsk"),(0,o.yg)("p",null,"The first part of the change is the base information for the task group.\nThis will require an additional optional attribute to be added.\nThe content of this optional attribute is a name, a string, which will be mapped to the name of the task group.\nThe field can be present on a real allocation and on a placeholder."),(0,o.yg)("p",null,"Proposed name for the new field is: ",(0,o.yg)("em",{parentName:"p"},"taskGroupName")),(0,o.yg)("p",null,"To distinguish normal AllocationAsks and placeholder AllocationAsks a flag must be added.\nThe flag will never have more than two values and thus maps to a boolean. As the default value for a boolean is ",(0,o.yg)("em",{parentName:"p"},"false")," the field should show the fact that it is an AllocationAsk that represents a placeholder as true."),(0,o.yg)("p",null,"Proposed name for the field is: ",(0,o.yg)("em",{parentName:"p"},"placeholder")),(0,o.yg)("p",null,"In patched message form that would look like:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"message AllocationAsk {\n...\n  // The name of the TaskGroup this ask belongs to\n  string taskGroupName = 10;\n  // Is this a placeholder ask (true) or a real ask (false), defaults to false\n  // ignored if the taskGroupName is not set\n  bool placeholder = 11;\n...\n}\n")),(0,o.yg)("p",null,"The last part of the task group information that needs to be communicated is the size of the task group.\nThis does not require a change in the interface as the current AllocationAsk object can support both possible options."),(0,o.yg)("p",null,"Requests can be handled in two ways:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Each member of the task group is passed to the core as a separate AllocationAsk with a maxAllocations, or the ask repeat, of 1"),(0,o.yg)("li",{parentName:"ol"},"The task group is considered one AllocationAsk with a maxAllocations set to the same value as minMember of the task group information.")),(0,o.yg)("p",null,"With option A the shim will need to generate multiple AllocationAsk objects and pass each to the core for scheduling.\nEach AllocationAsk is linked to one pod.\nOption B will only generate one AllocationAsk for all placeholder pods.\nOption B requires less code and has less overhead on the core side.\nHowever the logic on the shim side might be more complex as the returned allocation needs to be linked to just one pod."),(0,o.yg)("p",null,"Proposal is to use option: A"),(0,o.yg)("h3",{id:"allocation"},"Allocation"),(0,o.yg)("p",null,"Similar to the change for the ",(0,o.yg)("em",{parentName:"p"},"AllocationAsk")," the ",(0,o.yg)("em",{parentName:"p"},"Allocation")," requires additional optional attributes to be added.\nThe new fields distinguish a normal Allocation and placeholder Allocations on recovery.\nThe same rules apply to these fields as the ones added to the ",(0,o.yg)("em",{parentName:"p"},"AllocationAsk"),"."),(0,o.yg)("p",null,"The content of this optional attribute is a name, a string, which will be mapped to the name of the task group.\nThe field can be present on a real allocation and on a placeholder."),(0,o.yg)("p",null,"Proposed name for the new field is: ",(0,o.yg)("em",{parentName:"p"},"taskGroupName")),(0,o.yg)("p",null,"The flag will never have more than two values and thus maps to a boolean.\nAs the default value for a boolean is ",(0,o.yg)("em",{parentName:"p"},"false")," the field should show the fact that it is an Allocation that represents a placeholder as true."),(0,o.yg)("p",null,"Proposed name for the field is: ",(0,o.yg)("em",{parentName:"p"},"placeholder")),(0,o.yg)("p",null,"In patched message form that would look like:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"message Allocation {\n...\n  // The name of the TaskGroup this allocation belongs to\n  string taskGroupName = 11;\n  // Is this a placeholder allocation (true) or a real allocation (false), defaults to false\n  // ignored if the taskGroupName is not set\n  bool placeholder = 12;\n...\n}\n")),(0,o.yg)("h3",{id:"allocationrelease-response-and-request"},"AllocationRelease Response and Request"),(0,o.yg)("p",null,"The name for the messages are based on the fact that the release is always triggered by the shim.\nIn case of preemption and or gang scheduling the release is not triggered from the shim but from the core.\nThat means the message name does not cover the usage. A response message might not have an associated request message.\nIt could be used to indicate direction but that is in this case confusing."),(0,o.yg)("p",null,"When a release is triggered from the core, for preemption or the placeholder allocation, a response is expected from the shim to confirm that the release has been processed.\nThis response must be distinguished from a request to release the allocation initiated by the shim.\nA release initiated by the shim must be followed by a confirmation from the core to the shim that the message is processed.\nFor releases initiated by the core no such confirmation message can or must be sent.\nIn the current request message there is no way to indicate that it is a confirmation message."),(0,o.yg)("p",null,"To fix the possible confusing naming the proposal is to merge the two messages into one message: ",(0,o.yg)("em",{parentName:"p"},"AllocationRelease"),"."),(0,o.yg)("p",null,"The ",(0,o.yg)("em",{parentName:"p"},"AllocationReleaseRequest")," is indirectly part of the ",(0,o.yg)("em",{parentName:"p"},"UpdateRequest")," message as it is contained in the ",(0,o.yg)("em",{parentName:"p"},"AllocationReleasesRequest"),".\nThe ",(0,o.yg)("em",{parentName:"p"},"AllocationReleaseResponse")," is part of the ",(0,o.yg)("em",{parentName:"p"},"UpdateResponse")," message.\nThe flow-on effect of the rename and merge of the two messages is a change in the two messages that contain them.\nThe message changes for ",(0,o.yg)("em",{parentName:"p"},"UpdateResponse")," and ",(0,o.yg)("em",{parentName:"p"},"AllocationReleasesRequest")," are limited to type changes of the existing fields."),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Message"),(0,o.yg)("th",{parentName:"tr",align:null},"Field ID"),(0,o.yg)("th",{parentName:"tr",align:null},"Old type"),(0,o.yg)("th",{parentName:"tr",align:null},"New type"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"UpdateResponse"),(0,o.yg)("td",{parentName:"tr",align:null},"3"),(0,o.yg)("td",{parentName:"tr",align:null},"AllocationReleaseResponse"),(0,o.yg)("td",{parentName:"tr",align:null},"AllocationRelease")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"AllocationReleasesRequest"),(0,o.yg)("td",{parentName:"tr",align:null},"1"),(0,o.yg)("td",{parentName:"tr",align:null},"AllocationReleaseRequest"),(0,o.yg)("td",{parentName:"tr",align:null},"AllocationRelease")))),(0,o.yg)("p",null,"In patched message form that would look like:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"message UpdateResponse {\n...\n  // Released allocation(s), allocations can be released by either the RM or scheduler.\n  // The TerminationType defines which side needs to act and process the message. \n  repeated AllocationRelease releasedAllocations = 3;\n...\n}\n\nmessage AllocationReleasesRequest {\n  // Released allocation(s), allocations can be released by either the RM or scheduler.\n  // The TerminationType defines which side needs to act and process the message. \n  repeated AllocationRelease releasedAllocations = 1;\n...\n}\n")),(0,o.yg)("p",null,"The merged message ",(0,o.yg)("em",{parentName:"p"},"AllocationRelease")," will consist of:"),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Field name"),(0,o.yg)("th",{parentName:"tr",align:null},"Content type"),(0,o.yg)("th",{parentName:"tr",align:null},"Required"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"partitionName"),(0,o.yg)("td",{parentName:"tr",align:null},"string"),(0,o.yg)("td",{parentName:"tr",align:null},"yes")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"applicationID"),(0,o.yg)("td",{parentName:"tr",align:null},"string"),(0,o.yg)("td",{parentName:"tr",align:null},"no")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"UUID"),(0,o.yg)("td",{parentName:"tr",align:null},"string"),(0,o.yg)("td",{parentName:"tr",align:null},"no")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"terminationType"),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("em",{parentName:"td"},"TerminationType")),(0,o.yg)("td",{parentName:"tr",align:null},"yes")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"message"),(0,o.yg)("td",{parentName:"tr",align:null},"string"),(0,o.yg)("td",{parentName:"tr",align:null},"no")))),(0,o.yg)("p",null,"Confirmation behaviour of the action should be triggered on the type of termination received.\nThe core will confirm the release to the shim of all types that originate in the shim and vice versa."),(0,o.yg)("p",null,"A confirmation or response uses the same ",(0,o.yg)("em",{parentName:"p"},"TerminationType")," as was set in the original message.\nAn example of this is a pod that is removed from K8s will trigger an ",(0,o.yg)("em",{parentName:"p"},"AllocationRelease _message to be sent from the shim to the core with the TerminationType STOPPED_BY_RM. The core processes the request removing the allocation from the internal structures, and when all processing is done it responds to the shim with a message using the same _TerminationType"),".\nThe shim can ignore that or make follow up changes if needed."),(0,o.yg)("p",null,"A similar process happens for a release that originates in the core.\nExample of the core sending an ",(0,o.yg)("em",{parentName:"p"},"AllocationRelease")," message to the shim using the ",(0,o.yg)("em",{parentName:"p"},"TerminationType")," PREEMPTED_BY_SCHEDULER.\nThe shim handles that by releasing the pod identified and responds to the core that it has released the pod.\nOn receiving the confirmation that the pod has been released the core can progress with the allocation and preemption processing."),(0,o.yg)("p",null,"In patched message form that would look like:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"message AllocationRelease {\n  enum TerminationType {\n    STOPPED_BY_RM = 0;\n    TIMEOUT = 1; \n    PREEMPTED_BY_SCHEDULER = 2;\n    PLACEHOLDER_REPLACED = 3;\n  }\n\n  // The name of the partition the allocation belongs to\n  string partitionName = 1;\n  // The application the allocation belongs to\n  string applicationID = 2;\n  // The UUID of the allocation to release, if not set all allocations are released for\n  // the applicationID\n  string UUID = 3;\n  // The termination type as described above \n  TerminationType terminationType = 4;\n  // human-readable message\n  string message = 5;\n}\n")),(0,o.yg)("h3",{id:"terminationtype"},"TerminationType"),(0,o.yg)("p",null,"The currently defined ",(0,o.yg)("em",{parentName:"p"},"TerminationType")," values and specification of the side that generates (Sender), and the side that actions and confirms processing (Receiver):"),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Value"),(0,o.yg)("th",{parentName:"tr",align:null},"Sender"),(0,o.yg)("th",{parentName:"tr",align:null},"Receiver"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"STOPPED_BY_RM"),(0,o.yg)("td",{parentName:"tr",align:null},"shim"),(0,o.yg)("td",{parentName:"tr",align:null},"core")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"TIMEOUT *"),(0,o.yg)("td",{parentName:"tr",align:null},"core"),(0,o.yg)("td",{parentName:"tr",align:null},"shim")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"PREEMPTED_BY_SCHEDULER *"),(0,o.yg)("td",{parentName:"tr",align:null},"core"),(0,o.yg)("td",{parentName:"tr",align:null},"shim")))),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"currently not handled by the shim, core or both")),(0,o.yg)("p",null,"When the placeholder allocation gets released the ",(0,o.yg)("em",{parentName:"p"},"AllocationReleaseResponse")," is used to communicate the release back from the core to the shim.\nThe response contains an enumeration called ",(0,o.yg)("em",{parentName:"p"},"TerminationType"),", and a human-readable message.\nFor tracking and tracing purposes we should add a new ",(0,o.yg)("em",{parentName:"p"},"TerminationType")," specifically for the placeholder replacement. The shim must take action based on the type and confirm the allocation release to the core."),(0,o.yg)("p",null,"It should provide enough detail so we do not have to re-use an already existing type, or the human-readable message.\nThe human-readable format can still be used to provide further detail on which new allocation replaced the placeholder."),(0,o.yg)("p",null,"Proposal is to add: ",(0,o.yg)("em",{parentName:"p"},"PLACEHOLDER_REPLACED")),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Value"),(0,o.yg)("th",{parentName:"tr",align:null},"Sender"),(0,o.yg)("th",{parentName:"tr",align:null},"Receiver"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"PLACEHOLDER_REPLACED"),(0,o.yg)("td",{parentName:"tr",align:null},"shim"),(0,o.yg)("td",{parentName:"tr",align:null},"core")))),(0,o.yg)("p",null,"As part of the Scheduler Interface cleanup (",(0,o.yg)("a",{parentName:"p",href:"https://issues.apache.org/jira/browse/YUNIKORN-486"},"YUNIKORN-486"),") the ",(0,o.yg)("em",{parentName:"p"},"TerminationType")," should be extracted from the ",(0,o.yg)("em",{parentName:"p"},"AllocationRelease")," and ",(0,o.yg)("em",{parentName:"p"},"AllocationaskRelease")," message.\nIt is an enumeration that can be shared between multiple objects.\n",(0,o.yg)("a",{parentName:"p",href:"https://issues.apache.org/jira/browse/YUNIKORN-547"},"YUNIKORN-547")," has been logged to handle this as it has an impact on the code outside of the scope of gang scheduling."),(0,o.yg)("h3",{id:"allocationaskrelease-response-and-request"},"AllocationAskRelease Response and Request"),(0,o.yg)("p",null,"The allocation ask release right now can only be triggered by the shim.\nIn order for the core to perform the cleanup when the placeholder allocation times out, we need to make this a bidirectional message.\nSimilarly to the Allocation we would rename the ",(0,o.yg)("em",{parentName:"p"},"AllocationAskReleaseRequest")," to ",(0,o.yg)("em",{parentName:"p"},"AllocationAskRelease"),", so we can use this message in both directions:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"message AllocationReleasesRequest {\n...\n  // Released allocationask(s), allocationasks can be released by either the RM or\n  // scheduler. The TerminationType defines which side needs to act and process the\n  // message. \n  repeated AllocationAskRelease allocationAsksToRelease = 2;\n}\n")),(0,o.yg)("p",null,"Similar processing logic based on the ",(0,o.yg)("em",{parentName:"p"},"TerminationType")," which is used for allocations should be used for ask releases.\nIn patched message form that would look like:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"message AllocationAskRelease {\n  enum TerminationType {\n    STOPPED_BY_RM = 0;\n    TIMEOUT = 1; \n    PREEMPTED_BY_SCHEDULER = 2;\n    PLACEHOLDER_REPLACED = 3;\n  }\n...\n  // The termination type as described above \n  TerminationType terminationType = 4;\n...\n}\n")),(0,o.yg)("p",null,"Confirmation behaviour of the action should be triggered on the type of termination received.\nThe core will confirm the release to the shim of all types that originate in the shim and vice versa."),(0,o.yg)("p",null,"A confirmation or response uses the same ",(0,o.yg)("em",{parentName:"p"},"TerminationType")," as was set in the original message."),(0,o.yg)("h2",{id:"scheduler-storage-object-changes"},"Scheduler storage object changes"),(0,o.yg)("h3",{id:"allocationask-1"},"AllocationAsk"),(0,o.yg)("p",null,"In line with the changes for the communication the objects in the scheduler also need to be modified to persist some of the detail communicated.\nThe AllocationAsk that is used in the communication has an equivalent object inside the scheduler with the same name.\nThis object needs to be able to store the new fields proposed above."),(0,o.yg)("p",null,"Proposed new fields: ",(0,o.yg)("em",{parentName:"p"},"taskGroupName")," and ",(0,o.yg)("em",{parentName:"p"},"placeholder"),"."),(0,o.yg)("p",null,"In the current interface specification a field called ",(0,o.yg)("em",{parentName:"p"},"executionTimeoutMilliSeconds")," is defined.\nThis is currently not mapped to the object inside the scheduler and should be added.\nTime or Duration are stored as native go objects and do not include a size specifier."),(0,o.yg)("p",null,"Proposed new field: ",(0,o.yg)("em",{parentName:"p"},"execTimeout")),(0,o.yg)("h3",{id:"allocation-1"},"Allocation"),(0,o.yg)("p",null,"After the allocation is made an Allocation object is created in the core to track the real allocation. This Allocation object is directly linked to the application and should show that the allocation is a placeholder and for which task group. This detail is needed to also enable the correct display of the resources used in the web UI."),(0,o.yg)("p",null,"The propagation of the placeholder information could be achieved indirectly as the allocation object references an AllocationAsk. This would require a lookup of the AllocationAsk to assess the type of allocation. We could also opt to propagate the data into the Allocation object itself. This would remove the lookup and allow us to directly filter allocations based on the type and or task group information."),(0,o.yg)("p",null,"From a scheduling and scheduler logic perspective the indirect reference is not really desirable due to the overhead of the lookups required. This means that the same fields added in the AllocationAsk are also added to the Allocation object."),(0,o.yg)("p",null,"Proposed new fields: ",(0,o.yg)("em",{parentName:"p"},"taskGroupName")," and ",(0,o.yg)("em",{parentName:"p"},"placeholder"),"."),(0,o.yg)("p",null,"To support the release of the allocation being triggered from the core tracking of the release action is required. The release is not final until the shim has confirmed that release. However during that time period the allocation may not be released again."),(0,o.yg)("p",null,"Proposed new field: ",(0,o.yg)("em",{parentName:"p"},"released")),(0,o.yg)("p",null,"At the point that we replace the placeholder with a real allocation we need to release an existing placeholder.\nThe Allocation object allows us to specify a list of Allocations to release.\nThis field was added earlier to support preemption.\nThis same field will be reused for the placeholder release."),(0,o.yg)("h3",{id:"application"},"Application"),(0,o.yg)("p",null,"The AddApplicationRequest has a new field added that needs to be persisted in the object inside the scheduler."),(0,o.yg)("p",null,"Proposed new field: ",(0,o.yg)("em",{parentName:"p"},"placeholderAsk")),(0,o.yg)("p",null,"In the current interface specification a field called ",(0,o.yg)("em",{parentName:"p"},"executionTimeoutMilliSeconds")," is defined. This is currently not mapped to the object inside the scheduler and should be added. Time or Duration are stored as native go objects and do not include a size specifier."),(0,o.yg)("p",null,"Proposed new field: ",(0,o.yg)("em",{parentName:"p"},"execTimeout")),(0,o.yg)("p",null,"The application object should be able to track the placeholder allocations separately from the real allocations. The split of the allocation types on the application will allow us to show the proper state in the web UI."),(0,o.yg)("p",null,"Proposed new field: ",(0,o.yg)("em",{parentName:"p"},"allocatedPlaceholder")),(0,o.yg)("h3",{id:"queue--node"},"Queue & Node"),(0,o.yg)("p",null,"No changes at this point.\nThe placeholder allocations should be counted as \u201creal\u201d allocations on the Queue and Node.\nBy counting the placeholder as normal the quota for the queue is enforced as expected.\nThe Node object needs to also show normal usage to prevent interactions with the autoscaler."))}d.isMDXComponent=!0},18066:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/gang_clean_up-c2019679692548acac0667d84feea985.png"},88905:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/gang_generic_flow-7aa03e3ed0477897b3694adeb9e77253.png"},84294:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/gang_timeout-2e8b67c25538a8f49f7c059f113ac1b0.png"},91215:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/gang_total_ask-5962332571a96d36894af545be00f2b2.png"}}]);