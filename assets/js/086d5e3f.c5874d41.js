"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[536],{18589:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var o=a(13274),t=a(1780);const s={id:"resource_quota_management",title:"Resource Quota Management"},i=void 0,r={id:"user_guide/resource_quota_management",title:"Resource Quota Management",description:"\x3c!--",source:"@site/versioned_docs/version-0.9.0/user_guide/resource_quota_mgmt.md",sourceDirName:"user_guide",slug:"/user_guide/resource_quota_management",permalink:"/docs/0.9.0/user_guide/resource_quota_management",draft:!1,unlisted:!1,tags:[],version:"0.9.0",frontMatter:{id:"resource_quota_management",title:"Resource Quota Management"},sidebar:"docs",previous:{title:"ACLs",permalink:"/docs/0.9.0/user_guide/acls"},next:{title:"Run Spark Jobs",permalink:"/docs/0.9.0/user_guide/workloads/run_spark"}},u={},c=[{value:"Option 1) Static queues",id:"option-1-static-queues",level:2},{value:"Goal",id:"goal",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Run workloads",id:"run-workloads",level:3},{value:"Option 2) 1:1 mapping from namespaces to queues",id:"option-2-11-mapping-from-namespaces-to-queues",level:2},{value:"Goal",id:"goal-1",level:3},{value:"Configuration",id:"configuration-1",level:3},{value:"Set up namespaces",id:"set-up-namespaces",level:3},{value:"Run workloads",id:"run-workloads-1",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"YuniKorn can offer more fine-grained resource quota management comparing to simply\nusing namespace resource quota. Here are some how-to documents about setting up\nresource quota management with YuniKorn queues."}),"\n",(0,o.jsx)(n.h2,{id:"option-1-static-queues",children:"Option 1) Static queues"}),"\n",(0,o.jsx)(n.h3,{id:"goal",children:"Goal"}),"\n",(0,o.jsx)(n.p,{children:"Pre-setup a hierarchy of queues with min/max capacity, users can only submit\njobs to the leaf queues. This approach fully manages the resource capacity for\neach of the queues, which is suitable to the scenarios that queues do not change\ntoo often."}),"\n",(0,o.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"The following configuration is an example to demonstrate the format,\nyou need to setup the queue hierarchy based on your own structure and capacity,"})}),"\n",(0,o.jsx)(n.p,{children:"Apply the following configuration to YuniKorn's configmap:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"partitions:\n  -\n    name: default\n    queues:\n      -\n        name: root\n        submitacl: '*'\n        queues:\n          -\n            name: advertisement\n            resources:\n              guaranteed:\n                memory: 500000\n                vcore: 50000\n              max:\n                memory: 800000\n                vcore: 80000\n          -\n            name: search\n            resources:\n              guaranteed:\n                memory: 400000\n                vcore: 40000\n              max:\n                memory: 600000\n                vcore: 60000\n          -\n            name: sandbox\n            resources:\n              guaranteed:\n                memory: 100000\n                vcore: 10000\n              max:\n                memory: 100000\n                vcore: 10000\n"})}),"\n",(0,o.jsx)(n.p,{children:"in this example, we are going to setup 3 queues under root, and each of them has\na specific min/max capacity set up."}),"\n",(0,o.jsx)(n.h3,{id:"run-workloads",children:"Run workloads"}),"\n",(0,o.jsx)(n.p,{children:"In order to run jobs in specific queues, you will need to set the following label in all pods' spec:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'labels:\n  app: my-test-app\n  applicationId: " my-test-app-01"\n  queue: root.sandbox\n'})}),"\n",(0,o.jsx)(n.h2,{id:"option-2-11-mapping-from-namespaces-to-queues",children:"Option 2) 1:1 mapping from namespaces to queues"}),"\n",(0,o.jsx)(n.h3,{id:"goal-1",children:"Goal"}),"\n",(0,o.jsx)(n.p,{children:"User just needs to setup namespaces, YuniKorn automatically maps each namespace to an internal resource queue (AKA dynamical queue).\nThere is no additional steps to create YuniKorn queues, all queues will be created dynamically,\nresource allocation and quotas will be managed by YuniKorn instead of the namespace resource quota."}),"\n",(0,o.jsx)(n.h3,{id:"configuration-1",children:"Configuration"}),"\n",(0,o.jsx)(n.p,{children:"Apply the following configuration to YuniKorn's configmap:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"partitions:\n  -\n    name: default\n    placementrules:\n      - name: tag\n        value: namespace\n        create: true\n    queues:\n      - name: root\n        submitacl: '*'\n        properties:\n          application.sort.policy: stateaware\n\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note, the property ",(0,o.jsx)(n.code,{children:"application.sort.policy"})," in this configuration is set to\n",(0,o.jsx)(n.code,{children:"stateaware"}),". This is a simple app sorting policy applicable for batch jobs, you\ncan find more document ",(0,o.jsx)(n.a,{href:"/docs/0.9.0/user_guide/sorting_policies#StateAwarePolicy",children:"here"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["You can do this during the installation by overwriting the configuration in the\n",(0,o.jsx)(n.a,{href:"https://github.com/apache/incubator-yunikorn-release/blob/724ec82d0d548598e170cc6d5ca6aaae00f8286c/helm-charts/yunikorn/values.yaml#L71-L81",children:"helm chart template"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"set-up-namespaces",children:"Set up namespaces"}),"\n",(0,o.jsx)(n.p,{children:"Continue to create namespaces like before, do not create namespace quota anymore.\nInstead, set the following annotation in the namespace object:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'yunikorn.apache.org/namespace.max.cpu: "64"\nyunikorn.apache.org/namespace.max.memory: "100Gi"\n'})}),"\n",(0,o.jsx)(n.p,{children:"YuniKorn will parse the annotation and set the max capacity of the dynamical queue\nthat mapped to this namespace to 64 CPU and 100GB memory."}),"\n",(0,o.jsx)(n.h3,{id:"run-workloads-1",children:"Run workloads"}),"\n",(0,o.jsxs)(n.p,{children:["Jobs continue to be submitted to namespaces, based on the ",(0,o.jsx)(n.code,{children:"Placementrule"})," used\nin the configuration. YuniKorn will automatically run the job and all its pods in\nthe corresponding queue. For example, if a job is submitted to namespace ",(0,o.jsx)(n.code,{children:"development"}),",\nthen you will see the job is running in ",(0,o.jsx)(n.code,{children:"root.development"})," queue."]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1780:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>r});var o=a(79474);const t={},s=o.createContext(t);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);